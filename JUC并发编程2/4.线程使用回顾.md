

extend thread类 重写run方法

调用run()或者start()方法
run和start区别:
run在主线程执行代码，start启动新线程执行代码

class实现runnable接口 重写run方法
然后new thread(class).start()

![img_14.png](img_14.png)

lambda表达式 （）->{}

![img_15.png](img_15.png)

启动线程的三种方法？

    除了上面两种，通过线程池来启动

thread.yield() 是什么？

    RUNNING状态的线程进入 RUNNABLE 的ready
    让一下CPU资源，无法保证其他线程能不能抢到

thread.join()
![img_16.png](img_16.png)
等t2结束了t1才执行 把两个线程和成一个

t1 t2 t3 如何顺序执行？ 

    在主线程里，依次调用t1.join(),t2.join(),t3.join()
    也可以在t1方法内部调用t2.join(),t2方法内部调用t3.join()

线程有几个状态？ 6个

    new 线程新生
    runnable 运行（ready->running）(running到ready就是调用thread.yield())
    blocked 阻塞
    waiting 等待 一直等
    timed_waiting 超时等待 等待固定时间
    terminated 终止

![img_17.png](img_17.png)

synchronized锁的是什么？
锁this 对象引用; 锁静态方法 锁对象的class

为什么synchronized是重入锁？

子类调用父类的方法，都是synchronized，就会死锁。是否可重入获取锁的时候判断否是当前线程


