虚拟线程的原理：
---

线程需要被调度才能执行任务，本质上是分配到CPU上执行。

对于由操作系统线程实现的平台线程，JDK 依赖于操作系统中的调度程序；

而对于虚拟线程，JDK 先将虚拟线程分配给平台线程，然后平台线程按照通常的方式由操作系统进行调度。

JDK 的虚拟线程调度器是一个以 FIFO 模式运行的 ForkJoinPool，调度器的默认并行度是可用于调度虚拟线程的平台线程数量，并行度可以通过设置启动参数调整。

注意：
---

虚拟线程适合运行大部分时间处于阻塞状态、通常等待 I/O 操作完成的任务。

但是，它们不适用于长时间运行的 CPU 密集型操作。

如果你的任务全是纯计算（如视频转码、加密解密），虚拟线程没用。因为 CPU 一直在忙，没有 IO 等待，不需要切换。这种场景平台线程更好。

PS: IO密集型任务不要用并行任务。

使用线程池 (推荐用于迁移)
---

虚拟线程不需要“池化”（因为创建销毁太便宜了），但为了兼容旧代码接口，JDK 提供了 ExecutorService 的适配：

```java
// 这是一个“每来一个任务就新建一个虚拟线程”的 Executor
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.range(0, 10000).forEach(i -> {
        executor.submit(() -> {
            Thread.sleep(1000); // 即使睡1秒，底层线程也不会阻塞
            return i;
        });
    });
} // try-with-resources 会自动等待所有任务完成
```

Spring Boot 3 与虚拟线程
---
application.properties 中加一行配置：
```properties
spring.threads.virtual.enabled=true
```

Spring Boot 会自动把内置的 Tomcat/Jetty 容器的线程池，替换成虚拟线程执行器。

以前 Tomcat 默认最大 200 个线程，并发高了就排队。

现在 Tomcat 可以轻松处理 2 万、20 万个并发请求，只要内存够大，且瓶颈不在 CPU 计算上。