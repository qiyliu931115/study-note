标记清除进行垃圾回收，会导致内存碎片，内存不规则，从而在创建对象分配内存时产生’空闲列表‘

如果是复制算法和标记整理算法，没有内存碎片，在创建对象分配内存时只需要指针碰撞。

指针碰撞：
---
假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，

空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，

那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。

空闲列表：
---
如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，

那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，

在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
