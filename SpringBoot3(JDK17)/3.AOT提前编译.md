# AOT (Ahead-of-Time, 提前编译)


在传统的 Spring（JIT 模式）中，你的应用启动时非常忙碌：

扫描 (Scanning): 扫描 classpath 下所有的 Jar 包。

反射 (Reflection): 读取注解、解析配置、通过反射实例化 Bean。

动态代理 (Proxies): 运行时生成 CGLIB 代理。

# AOT 的目标是：把这些在“启动时”做的事情，挪到“打包编译时”做完。

Spring AOT 引擎会在你运行 mvn package 时分析你的代码，然后自动生成注册 Bean 的 Java 代码。

## 以前： 
Spring 启动时通过反射问：“你是谁？怎么加载？”

## AOT： 
编译器在打包时直接生成代码：“我知道你是 MyController，直接 new MyController()，别搞反射那一套了。”


GraalVM（Native Image 的核心）要求在编译时必须知道所有的类、所有的反射调用、所有的动态代理。不允许在运行时突然加载一个未知的模块。

# 传统模式 vs AOT 模式

(JIT/Runtime): 启动时极其繁重，充满了“？”（扫描、猜测、反射）。

(AOT/Native): 繁重的工作在 Build 阶段由 Spring AOT Engine 完成了。它生成了 Source Code（辅助代码）和 Hint Files（提示文件）。最终的 Native Image 启动时是一条直线，极其快速。