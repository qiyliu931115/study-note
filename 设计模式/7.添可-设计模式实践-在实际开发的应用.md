开宗明义
---

在实际生产环境中，一些业务场景我们可以借助一些设计模式来实现我们的需要的功能。

本篇中，具体介绍了双重检查锁单例模式，代理模式，策略模式，观察者模式，状态模式，原型模式，责任链模式7个设计模式的应用场景和实际需求中的应用。


双重检查锁单例模式
---
##### 应用场景

双重检查单例模式是一种线程安全的单例模式实现方式，可以在实际生产中应用于需要保证全局唯一性的场景，例如：

数据库连接池：在一个应用中，可能需要多个线程同时访问数据库，为了避免每次访问数据库都需要创建新的连接，可以使用单例模式来创建数据库连接池，保证全局唯一性，提高数据库访问的效率。

日志记录器：在一个应用中，可能需要多个线程同时记录日志，为了避免日志记录器的实例被多个线程创建，可以使用单例模式来创建日志记录器，保证全局唯一性，避免日志记录的重复和混乱。

配置文件管理器：在一个应用中，可能需要多个线程同时访问配置文件，为了避免每次访问配置文件都需要创建新的实例，可以使用单例模式来创建配置文件管理器，保证全局唯一性，提高配置文件访问的效率。

需要注意的是，双重检查单例模式虽然可以保证线程安全，但是在一些特殊的场景下可能会出现问题，例如在多线程环境下，如果一个线程正在创建实例，而另一个线程同时访问了getInstance方法，可能会导致实例被创建多次。因此，在使用双重检查单例模式时，需要仔细考虑线程安全性和性能问题，确保能够满足实际需求。

##### 具体实现

在高可用架构中，为了在系统发生故障时能限定传播范围和影响范围，不会出现滚雪球效应。我们一般采用隔离的方式。

具体如：线程隔离，进程隔离，读写隔离，集群隔离，机房隔离，冷热隔离，动静隔离，爬虫隔离等。

在线程隔离中，很多情况下我们需要一个线程池来对一个接口和其他接口做线程隔离，在该接口的方法内会使用单独的线程池来处理业务逻辑，来实现线程隔离的效果。

在这里就具体说明下使用双重检查单例创建一个线程池及注意事项。

```java
public class DoubleCheckSingleton {

    private static volatile ThreadPoolTaskExecutor threadPoolTaskExecutor = null;

    public DoubleCheckSingleton () {
        System.out.println(Thread.currentThread().getName() + ":DoubleCheckSingleton");
    }

    public static ThreadPoolTaskExecutor getInstance() {
        if (threadPoolTaskExecutor == null) {
            synchronized (DoubleCheckSingleton.class) {
                if (threadPoolTaskExecutor == null) {
                    ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
                    threadPoolTaskExecutor.setCorePoolSize(5);
                    threadPoolTaskExecutor.setMaxPoolSize(5);
                    threadPoolTaskExecutor.setThreadNamePrefix("AsyncEventExecutor-");
                    threadPoolTaskExecutor.initialize();
                    return threadPoolTaskExecutor;
                }
            }
        }
        return threadPoolTaskExecutor;
    }

    public static void main(String[] args) {
        ThreadPoolTaskExecutor instance = getInstance();
        instance.execute(new Runnable() {
            @Override
            public void run() {
                // 执行任务
            }
        });
    }
}

```
Class锁

双重检查锁单例模式中，使用锁来保证线程安全，锁的对象是Singleton.class，而不是this对象，是因为this对象在多线程环境下是不安全的。

在单例模式中，单例对象是在类加载的时候就被创建出来的，因此锁的对象应该是类对象，而不是实例对象。

使用Singleton.class作为锁对象，可以保证在多线程环境下，只有一个线程可以进入同步代码块，创建单例对象。

而使用this对象作为锁对象，会出现多个实例的情况，因为在多线程环境下，每个线程都有自己的实例对象，锁的是自己的实例对象，无法保证只有一个线程可以进入同步代码块。

另外，使用Singleton.class作为锁对象，可以保证在类加载的时候就被初始化，避免了在多线程环境下出现多个实例的情况。

而使用this对象作为锁对象，需要在实例化之后才能使用，无法保证在实例化之前不会出现多个实例的情况。

volatile关键字

双重检查锁单例模式中，使用volatile关键字来修饰单例对象的变量，是为了保证多线程环境下的可见性和有序性。

在双重检查锁单例模式中，第一次检查单例对象是否为null时，如果多个线程同时进入了这个判断语句，

那么它们都会认为单例对象为null，然后会进入同步代码块中，创建单例对象。

但是，如果没有使用volatile关键字来修饰单例对象的变量，那么在某个线程创建单例对象之后，其他线程可能无法立即看到这个变化，仍然会认为单例对象为null，

然后继续创建单例对象，这样就会创建多个实例，违背了单例模式的初衷。

使用volatile关键字来修饰单例对象的变量，可以保证在多线程环境下，单例对象的变化对其他线程是可见的，从而避免了创建多个实例的问题。

同时，volatile关键字还可以保证单例对象的创建是有序的，避免了指令重排的问题。

单例模式的实现不难，只是我们要考虑在什么场景使用单例，且要关注我们编写代码创建的对象实例到底是不是单例。

代理模式
---
##### 应用场景

远程代理：远程代理可以在客户端和远程服务之间建立代理，客户端不需要知道服务的具体实现，只需要和代理交互即可。例如，RMI（远程方法调用）就是一种常见的远程代理模式。

虚拟代理：虚拟代理可以在需要大量资源的情况下，延迟实际的对象创建和加载，以避免不必要的开销。例如，一个包含大量图片的网页，可以使用虚拟代理模式来实现，只有当用户需要查看某一张图片时，才会加载该图片，避免了页面加载时的不必要资源消耗。

安全代理：安全代理可以控制对象的访问权限，在客户端和真实对象之间建立代理，对客户端的访问进行安全控制。例如，一个文件系统的安全代理可以控制用户对文件的访问权限，避免文件被不允许的用户访问。

智能指引代理：智能指引代理可以在访问对象时增加一些额外的功能，例如，统计访问次数，缓存对象，对对象进行延迟加载等等。例如，一个ORM框架可以使用智能指引代理来支持延迟加载和缓存数据。

缓存代理：缓存代理可以在访问对象时使用缓存，避免每次都去访问真实对象，从而提高访问速度。例如，一个Web应用可以使用缓存代理来缓存数据，避免每次都去查询数据库，从而提高应用的性能。

##### 具体实现

在Java的Spring框架中，AOP思想的实现的一般都是基于代理模式，其中有JDK和CJLIB的实现方案，也可以集成AspectJ的实现AOP。

代理模式的实现场景非常广泛，在RPC,缓存，监控等场景都有广泛的应用。

这里聊一个使用代理模式来实现的轻量化的限流降级功能（开源的有阿里的Sentinel）。

@RateLimit 注解说明

```java
@Target(value = {ElementType.METHOD})
@Retention(value = RetentionPolicy.RUNTIME)
public @interface RateLimit {

    /**
     * 时间窗口流量数量
     * @return rate
     */
    long rate();

    /**
     * 时间窗口流量数量表达式
     * @return rateExpression
     */
    String rateExpression() default "";

    /**
     * 时间窗口，最小单位秒，如 2s，2h , 2d
     * @return rateInterval
     */
    String rateInterval();

    /**
     * 获取key
     * @return keys
     */
    String [] keys() default {};

    /**
     * 限流后的自定义回退后的拒绝逻辑
     * @return fallback
     */
    String fallbackFunction() default "";

    /**
     * 自定义业务 key 的 Function
     * @return key
     */
    String customKeyFunction() default "";

    /**
     * 每次请求令牌的数量(令牌桶模式参数) 默认为1
     * @return quantity
     */
    long quantity() default 1L;

    /**
     * 令牌桶的容量(令牌桶模式参数) 默认为10
     * @return quantity
     */
    long maxQuantity() default 10L;

    /**
     * 限流模式 默认是固定时间计数器模式
     * @return
     */
    RateLimitModel model() default RateLimitModel.COUNT;
    
}
```

RateLimitAspectHandler定义Aspect切面，使用@Around注解，所有被Spring管理的Bean，不限类和方法，只要有@RateLimit注解都会执行RateLimitAspectHandler.around方法

方法内会解析注解，并执行Lua脚本进行限流判断，被限流返回限流告警，如果配置了降级方法限流后就会执行降级方法


```java
@Aspect
@Component
@Order(0)
@Slf4j
@ConditionalOnProperty(prefix = RateLimiterProperties.PREFIX, name = "enabled", havingValue = "true")
public class RateLimitAspectHandler {

    private final RateLimiterService rateLimiterService;
    private final RScript rScript;

    public RateLimitAspectHandler(RedissonClient client, RateLimiterService lockInfoProvider) {
        this.rateLimiterService = lockInfoProvider;
        this.rScript = client.getScript();
    }

    @Around(value = "@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable {
        //解析注解
        RateLimiterInfo limiterInfo = rateLimiterService.getRateLimiterInfo(joinPoint, rateLimit);

        if (limiterInfo.getModel().equals(RateLimitModel.COUNT.type())) {
            List<Object> keys = new ArrayList<>();
            keys.add(limiterInfo.getKey());
            keys.add(limiterInfo.getRate());
            keys.add(limiterInfo.getRateInterval());
            List<Long> results = rScript.eval(RScript.Mode.READ_WRITE, LuaScript.getRateLimiterScript(), RScript.ReturnType.MULTI, keys);
            boolean allowed =
                    results.get(0) == 0L;
            if (!allowed) {
                if (StringUtils.hasLength(rateLimit.fallbackFunction())) {
                    return rateLimiterService.executeFunction(rateLimit.fallbackFunction(), joinPoint);
                }
                long ttl = results.get(1);
                log.info("Trigger current limiting, key:{}", limiterInfo.getKey());
                throw new RateLimitException("Too Many Requests", ttl);
            }
        } else {
            List<Object> keys = new ArrayList<>();
            //标识
            keys.add(limiterInfo.getKey());
            //令牌桶最大容量
            keys.add(limiterInfo.getMaxQuantity());
            //时间窗口内的限额
            keys.add(limiterInfo.getRate());
            //时间窗口大小（秒）
            keys.add(limiterInfo.getRateInterval());
            //请求的令牌数量
            keys.add(limiterInfo.getQuantity());
            //执行lua脚本
            List<Long> results = rScript.eval(RScript.Mode.READ_WRITE, TokenBucketLuaScript.getTokenBucketLuaScript(), RScript.ReturnType.MULTI, keys);
            boolean allowed =
                    results.get(0) == 0L;
            if (!allowed) {
                Map<String, String> map = new HashMap<String, String>(4);
                map.put("Current Limiting", results.get(0) == 0 ? "NO" :"YES");
                map.put("Total Quantity", results.get(1).toString());
                map.put("Available Capacity", results.get(2).toString());
                map.put("Apply for Quantity", String.valueOf(limiterInfo.getQuantity()));
                log.debug("Trigger current limiting, key:{}, info: {}", limiterInfo.getKey(), map);
                if (StringUtils.hasLength(rateLimit.fallbackFunction())) {
                    //如果有fallback方法就会执行降级方法
                    return rateLimiterService.executeFunction(rateLimit.fallbackFunction(), joinPoint);
                }
                throw new RateLimitException("Too Many Requests", map);
            }
        }
        return joinPoint.proceed();
    }
}
```

@RateLimit使用在方法上

```java
      /**
      * 令牌桶（rate=10， rateInterval=10s, 在10秒内会匀速生成10个令牌，也就是说在第一次请求开始后10秒内每秒会生成1个令牌，maxQuantity=10 令牌桶最大容量是10，超过10后生成的令牌会被丢弃，quantity=3 每次请求需要从令牌桶里拿出消耗3个令牌）
      * @return
      */
      @GetMapping("/tokenBucket")
      @RateLimit(rate = 10, rateInterval = "10s", quantity = 3, maxQuantity = 10, model = RateLimitModel.TOKEN_BUCKET, fallbackFunction = "getFallback")
      public ResponseMessage tokenBucket(String name) {
            return ResponseMessage.ok("tokenBucket");
      }
    
      /**
      * keys 的语法来自 spring 的 Spel，可以获取对象入参里的属性，支持获取多个，最后会拼接起来。使用过 spring-cache 的同学可能会更加熟悉 如果不清楚 Spel 的用法，可以参考 spring-cache 的注解文档。
      */
      @PostMapping("/user")
      @RateLimit(rate = 5, rateInterval = "10s",keys = {"#user.name","user.id"})
      public String user(@RequestBody User user) {
            return "user";
      }
    
```

如果被限流了就会调用该方法

```java
/**
* 降级策略
*
* @param name
* @return
  */
  public ResponseMessage getFallback(String name){
  return ResponseMessage.ok("你被限流了");
  }
```

##### Vue中代理模式的应用

Vue 通过代理模式实现了数据劫持（数据劫持也称为数据代理）和响应式更新。

在 Vue 中，数据劫持是通过代理对象来实现的。代理对象是一个空的对象，它通过 Object.defineProperty 或 ES6 中的 Proxy 对数据对象进行监听，从而实现数据的响应式更新。在 Vue 中，每个组件实例都有一个代理对象，代理对象中的属性和方法都可以直接访问到组件实例中的数据和方法。

通过代理模式，Vue 可以监听数据对象的变化，并在数据对象发生变化时，触发相关的响应式更新。在数据发生变化时，Vue 会更新组件中的模板，并重新渲染视图。

在 Vue 中，使用代理模式实现数据劫持和响应式更新，使得开发人员可以方便地开发响应式的应用，并能够轻松地通过数据的变化来更新应用的状态，从而实现了更好的用户体验。

##### 代理模式的滥用

Java开发都知道：在Spring Boot 框架中有AOP的功能，Java开发可以使用基于AOP的动态代理创建代理类来处理一些业务。

我之前所在的项目有因为开发在项目中过多使用代理模式，项目在启动时需要创建的的代理类过多，导致了项目启动长达五到十五分钟，非常缓慢（慢的原因不止代理类过多一个原因，只是占重较大）。

有人说启动慢很正常，很多大型项目启动很多都很慢，影响不大，其实并不见然。

对于需要频繁进行启动和重启操作的业务场景，如微服务架构、容器化部署、实时数据处理、私有云部署等，都需要项目启动速度和重启速度非常快，以保证业务的高效性和可靠性。

所以说项目启动速度慢的情况不容忽视。

##### 解决方案

减少代理类的数量：可以通过重构代码，减少代理类的数量。例如，可以将多个代理方法合并为一个方法，这样可以减少代理类的数量，从而加速项目的启动速度。

使用CGLIB代理：CGLIB代理可以避免使用Java动态代理时的接口问题，同时CGLIB代理可以提供更高的性能。可以尝试使用CGLIB代理，以便加速项目的启动速度。

使用缓存：可以使用缓存来避免重复创建代理类。例如，可以将代理类缓存起来，避免重复创建代理类，从而加速项目的启动速度。（原来的项目就是采用这个方案进行优化）

使用延迟加载：可以使用延迟加载来避免在项目启动时创建代理类。例如，可以在项目启动时只加载必要的类，然后在实际使用时再创建代理类，可以加速项目的启动速度。

使用其他框架：可以尝试使用其他框架，例如Dubbo等，这些框架可以提供更高的性能和更好的扩展性，可以解决代理类过多导致项目启动过慢的问题。

代理模式使用的场景非常之多，实现也并不困难，上面提到的具体实现也不复杂。

为什么要聊到代理模式，因为我曾遇到过滥用代理模式导致的代码问题，借此想给大家提个醒：如何衡量是否需要设计模式？过多的设计模式会不会有问题？

出现问题后，在不能改动使用设计模式写的业务代码的前提下，如何解决问题？

策略模式
---

##### 应用场景

策略模式是一种行为型设计模式，它定义了一系列算法，将每个算法都封装起来，并且使它们之间可以互换。策略模式可以让算法的变化独立于使用算法的客户端，从而实现了算法的动态切换和扩展。策略模式适用于以下场景：

多个类只有算法或行为上的不同，可以使用策略模式封装这些不同的算法或行为，使得它们可以互换，从而实现动态切换和扩展。

需要在运行时动态地选择算法或行为的场景，可以使用策略模式来实现。

需要封装一些复杂的算法或行为，使得客户端可以简化使用，可以使用策略模式来实现。

需要在不同的上下文中使用不同的算法或行为，可以使用策略模式来实现。

需要在算法或行为的实现上保持一定的独立性，可以使用策略模式来实现。

总之，策略模式适用于需要封装一系列算法或行为，并且需要动态切换和扩展这些算法或行为的场景。它可以使得算法或行为的变化独立于使用算法或行为的客户端，从而提高代码的可维护性、可扩展性和可重用性。

##### 具体实现

添可电器商品功能：在购物车及提交订单时计算商品是否参加活动及最低价格

首先定义了一个计算商品价格到策略接口，这个接口定义了计算价格到方法和返回值，以及不同策略所属到活动类型

```java
/**
 * 活动商品计算价格
 */
public interface ActivityGoodsCalculatePriceStrategy {

    /**
     * 根据活动来计算商品价格
     * @param calculatePriceRequest 商品原价及数量等信息
     * @return CalculatePriceResponse
     */
    CalculatePriceResponse calculatePrice(CalculatePriceRequest calculatePriceRequest);

    /**
     * 获取活动类型
     * @return ActivityType
     */
    ActivityType getActivityType();
}
```

ActivityType作为枚举，定义不同到活动到类型枚举和活动名称 用于后端逻辑判断和返回前端使用

```java
public enum ActivityType {

    NORMAL(0,"不参加活动"),
    DISCOUNT(1,"满折活动"),

    ;
    private final Integer code;
    private final String message;

    ActivityType(Integer code, String message) {
        this.code = code;
        this.message = message;
    }

    public Integer getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }

    public static String getMessageByCode(Integer code) {
        if (null == code) {
            return null;
        }
        for (ActivityType value : values()) {
            if (value.getCode().equals(code)) {
                return value.message;
            }
        }
        return null;
    }

    public static ActivityType getByCode(Integer code) {
        if (null == code) {
            return null;
        }
        for (ActivityType value : values()) {
            if (value.getCode().equals(code)) {
                return value;
            }
        }
        return null;
    }
}
```
CalculatePriceRequest作为请求数据 包含了商品id，商品正常价格，商品数量（购物车和提交订单页面的商品数量）等数据

```java
/**
 * 计算商品价格请求数据
 */
@Data
public class CalculatePriceRequest {

    @ApiModelProperty("goods_common表id(SPU)")
    @NotNull
    private Long goodsCommonId;

    @ApiModelProperty("goods_base表id(SKU)")
    @NotNull
    private Long goodsBaseId;

    @ApiModelProperty("商品原价（正常价格）")
    @NotNull
    private BigDecimal originalPrice;

    @ApiModelProperty("商品数量")
    @NotNull
    private Integer quantity;

    /**
     * 活动类型 1-满折活动
     *
     * @see ActivityType
     */
    @ApiModelProperty("指定活动类型，如传入1代表只按满折活动来计算活动总价，即使商品参加其他活动且活动总价比满折活动低，依然按满折活动计算")
    @NotNull
    private Integer activityType;
}
```

CalculatePriceResponse封装了计算价格到结果，封装了是否参与活动 活动id 活动类型 活动说明 活动价

以及同一个商品有多件 有几件可以参与活动 有多少件不能参加活动 （例如限购活动中，只能有一件按活动价 其余按原价 按原价到商品可以使用优惠券）

```java
/**
 * 商品计算价格结果
 */
@Data
public class CalculatePriceResponse {

    @ApiModelProperty("活动ID")
    private Long activityId;

    @ApiModelProperty("参与活动的商品总价: 如满折活动：商品原价 * 参加活动的商品数量 * 折扣")
    private BigDecimal activityPrice;

    @ApiModelProperty("参与活动的商品单价: 如满折活动：商品原价 * 折扣。没有参加任何活动这里就是原价")
    private BigDecimal activityGoodsPrice;

    @ApiModelProperty("参与活动的商品数量")
    private Integer activityQuantity;

    @ApiModelProperty("未参与活动的商品数量")
    private Integer notJoinActivityQuantity;

    @ApiModelProperty("差价（参加活动的商品原总价 - 参与活动的商品总价）")
    private BigDecimal priceDifference;

    /**
     * 活动类型 1-满折活动
     *
     * @see ActivityType
     */
    @ApiModelProperty("活动类型 0-不参加活动，1-满折活动")
    private Integer activityType;

    @ApiModelProperty("活动详情描述,如：该商品满两件8折，三件5折")
    private String activityDesc;
}
```


AbstractActivityGoodsCalculatePriceStrategy实现了ActivityGoodsCalculatePriceStrategy接口，作为默认到计算商品价格的策略 

如果商品不参加任何活动，计算价格到逻辑就由AbstractActivityGoodsCalculatePriceStrategy处理

```java
/**
 * 不参与任何活动商品的计算价格策略
 */
@Slf4j
@Service
public class AbstractActivityGoodsCalculatePriceStrategy implements ActivityGoodsCalculatePriceStrategy {


    private static final ActivityType activityType = ActivityType.NORMAL;
    /**
     * 该商品任何活动都没参加
     *
     * @param calculatePriceRequest
     * @return
     */
    @Override
    public CalculatePriceResponse calculatePrice(CalculatePriceRequest calculatePriceRequest) {
        BigDecimal originalPrice = calculatePriceRequest.getOriginalPrice();
        Integer quantity = calculatePriceRequest.getQuantity();
        CalculatePriceResponse calculatePriceResponse = new CalculatePriceResponse();
        BigDecimal originalTotalPrice = originalPrice.multiply(BigDecimal.valueOf(quantity));
        calculatePriceResponse.setActivityPrice(originalTotalPrice);
        calculatePriceResponse.setActivityQuantity(0);
        calculatePriceResponse.setNotJoinActivityQuantity(quantity);
        calculatePriceResponse.setActivityType(activityType.getCode());
        //差价 （商品总价 - 参与活动的商品总价） 无活动参加 差价是0
        calculatePriceResponse.setPriceDifference(BigDecimal.ZERO);
        //参加活动后每个商品的单价 这里没有参加任何活动就是原价
        calculatePriceResponse.setActivityGoodsPrice(originalPrice);
        //不参加任何活动 设置为0
        calculatePriceResponse.setActivityId(0L);
        log.info("AbstractActivityGoodsCalculatePriceStrategy calculatePrice Result ：{}", JSONObject.toJSONString(calculatePriceResponse));
        return calculatePriceResponse;
    }

    @Override
    public ActivityType getActivityType() {
        return activityType;
    }
}

```

DiscountActivityStrategy继承了AbstractActivityGoodsCalculatePriceStrategy

如果如果商品参与了满折活动就由DiscountActivityStrategy处理，如果满折活动计算价格发生异常 就由AbstractActivityGoodsCalculatePriceStrategy处理

```java
/**
 * 参与满折活动商品的计算价格策略
 */
@Slf4j
@Service
public class DiscountActivityStrategy extends AbstractActivityGoodsCalculatePriceStrategy implements ActivityGoodsCalculatePriceStrategy {


    @Autowired
    private DiscountActivityGoodsMapper discountActivityGoodsMapper;

    private static final ActivityType activityType = ActivityType.DISCOUNT;
    @Override
    public CalculatePriceResponse calculatePrice(CalculatePriceRequest calculatePriceRequest) {

        try {
            CalculatePriceRequest calculatePriceRequest1 = calculatePriceRequest;
            Long goodsBaseId = calculatePriceRequest1.getGoodsBaseId();
            Integer quantity = calculatePriceRequest1.getQuantity();
            BigDecimal originalPrice = calculatePriceRequest1.getOriginalPrice();
            List<DiscountActivityGoodsInfo> discountActivityGoodsInfoList = discountActivityGoodsMapper.getByGoodsBaseId(goodsBaseId, quantity, new Date());
            if (CollectionUtils.isEmpty(discountActivityGoodsInfoList)) {
                return super.calculatePrice(calculatePriceRequest);
            }
            //取第一条最接近quantity的数据
            DiscountActivityGoodsInfo discountActivityGoodsInfo = discountActivityGoodsInfoList.get(0);
            CalculatePriceResponse calculatePriceResponse = getCalculatePriceResponse(discountActivityGoodsInfo, originalPrice, quantity);

            log.info("DiscountActivityStrategy calculatePrice Result ：{}", JSONObject.toJSONString(calculatePriceResponse));
            return calculatePriceResponse;
        } catch (Exception e) {
            //如果满折活动出现错误 使用默认的计算价格策略
            log.error("DiscountActivityStrategy calculatePrice Error : {}", ExceptionUtils.getStackTrace(e));
            return super.calculatePrice(calculatePriceRequest);
        }

    }

    @Override
    public ActivityType getActivityType() {
        return activityType;
    }

    /**
     * 组装活动数据
     *
     * @param discountActivityGoodsInfo
     * @param originalPrice
     * @param quantity
     * @return
     */
    private CalculatePriceResponse getCalculatePriceResponse(DiscountActivityGoodsInfo discountActivityGoodsInfo, BigDecimal originalPrice, Integer quantity) {
        //获取折扣 如7.00折 要将小数点左移1位
        //Integer conditionAmount = discountActivityGoodsInfo.getConditionAmount();
        BigDecimal discount = discountActivityGoodsInfo.getDiscount().movePointLeft(1);

        //参加活动的商品原总价：(商品原价* 数量)
        BigDecimal originalTotalPrice = originalPrice.multiply(BigDecimal.valueOf(quantity));

        CalculatePriceResponse calculatePriceResponse = new CalculatePriceResponse();
        //参与活动的商品总价: (商品原价 * 商品数量 * 折扣) 四舍五入保留两位小数
        BigDecimal activityPrice = originalPrice.multiply(BigDecimal.valueOf(quantity)).multiply(discount).setScale(2, RoundingMode.HALF_UP);
        calculatePriceResponse.setActivityPrice(activityPrice);
        //参与活动的商品数量
        calculatePriceResponse.setActivityQuantity(quantity);
        //未参加活动的商品数量
        calculatePriceResponse.setNotJoinActivityQuantity(0);
        calculatePriceResponse.setActivityType(activityType.getCode());
        //差价 （参加活动的商品原总价 - 参与活动的商品总价）
        calculatePriceResponse.setPriceDifference(originalTotalPrice.subtract(activityPrice));
        //参加活动后每个商品的单价
        calculatePriceResponse.setActivityGoodsPrice(originalPrice.multiply(discount));

        calculatePriceResponse.setActivityId(discountActivityGoodsInfo.getActivityId());

        return calculatePriceResponse;
    }
}
```
封装请求及响应数据结构，实现了不同计算价格到策略后

接下来就使用ActivityCalculatePriceProcessor来实现 一件商品如果参加了多个活动

不同的活动有不同价格算法策略，到底应该返回哪一种策略（参加什么活动）的逻辑

在购物车和提交订单时 后端接收到前端数据后 只需要将商品相关信息封装到CalculatePriceRequest后

调用ActivityCalculatePriceProcessor.calculatePrice方法即可获取最低价

目前添可电器商城只有满折活动 如果后续有其他活动 要比较一个商品参与不同活动的最低价格

新的活动计算价格逻辑代码 只需要继承AbstractActivityGoodsCalculatePriceStrategy类 重写calculatePrice方法即可

比较价格的逻辑由ActivityCalculatePriceProcessor处理


```java
/**
 * 活动商品计算价格
 */
@Slf4j
@Service
public class ActivityCalculatePriceProcessor implements InitializingBean {

    /**
     * 目前所有策略封装在list中
     * 后续扩展多个策略（活动）时，可以将list改为map key为活动类型 value为ActivityGoodsCalculatePriceStrategy具体策略
     */
    private List<ActivityGoodsCalculatePriceStrategy> strategies;

    @Autowired
    private ApplicationContext applicationContext;

    public ActivityCalculatePriceProcessor() {
        this.strategies = new ArrayList<>();
    }

    public void addStrategy(ActivityGoodsCalculatePriceStrategy strategy) {
        this.strategies.add(strategy);
    }

    /**
     * 获取所有的计算价格的策略
     * @throws Exception
     */
    @Override
    public void afterPropertiesSet() throws Exception {
        Map<String, ActivityGoodsCalculatePriceStrategy> beansOfType = applicationContext.getBeansOfType(ActivityGoodsCalculatePriceStrategy.class);
        for (ActivityGoodsCalculatePriceStrategy activityGoodsCalculatePriceStrategy : beansOfType.values()) {
            addStrategy(activityGoodsCalculatePriceStrategy);
        }
    }

    /**
     * 计算最低价格
     * @param calculatePriceRequest 商品原价及数量等信息
     * @return CalculatePriceResponse
     */
    public CalculatePriceResponse calculatePrice(CalculatePriceRequest calculatePriceRequest) {
        CalculatePriceResponse calculatePriceResponse = new CalculatePriceResponse();
        BigDecimal minPrice = BigDecimal.valueOf(Long.MAX_VALUE);
        for (ActivityGoodsCalculatePriceStrategy strategy : strategies) {
            CalculatePriceResponse calculatePriceResponseByStrategy= strategy.calculatePrice(calculatePriceRequest);
            if (calculatePriceResponseByStrategy.getActivityPrice().compareTo(minPrice) < 0) {
                minPrice = calculatePriceResponseByStrategy.getActivityPrice();
                calculatePriceResponse.setActivityPrice(minPrice);
                calculatePriceResponse.setActivityQuantity(calculatePriceResponseByStrategy.getActivityQuantity());
                calculatePriceResponse.setNotJoinActivityQuantity(calculatePriceResponseByStrategy.getNotJoinActivityQuantity());
                calculatePriceResponse.setActivityType(calculatePriceResponseByStrategy.getActivityType());
                calculatePriceResponse.setPriceDifference(calculatePriceResponseByStrategy.getPriceDifference());
                calculatePriceResponse.setActivityDesc(calculatePriceResponseByStrategy.getActivityDesc());
                calculatePriceResponse.setActivityId(calculatePriceResponseByStrategy.getActivityId());
                calculatePriceResponse.setActivityGoodsPrice(calculatePriceResponseByStrategy.getActivityGoodsPrice());
            }
        }
        log.info("calculatePrice Result ：{}", JSONObject.toJSONString(calculatePriceResponse));
        return calculatePriceResponse;
    }
}

```

calculatePrice方法是for循环比较不同策略的价格 返回一个最低价 这种循环的方法在策略较少时可以使用

后续策略太多的话 for循环串行计算价格的性能 就不如并行计算价格返回一起处理的性能好

例如JUC工具包中的CountDownLatch和CyclicBarrier

使用策略模式实现计算价格并比较的功能 多数情况下新增商品活动 计算活动价 只需要新加一个Strategy即可

比较价格的逻辑由Processor处理 计算价格和比较价格的逻辑分开隔离 尽量减少代码耦合

##### 策略模式在React中的使用场景

在 React 中，策略模式常常被用于实现组件的事件处理。策略模式是一种行为型模式，它将一组算法封装起来，使得它们可以相互替换，从而使得程序的行为可以根据不同的策略而变化。

在 React 中，事件处理器可以被视为策略，组件可以根据策略来进行事件的处理。常见的策略模式实现方式包括：

使用高阶组件（Higher Order Component）：高阶组件是一种函数，它接收一个组件作为参数，返回一个新的组件。可以通过高阶组件来封装事件处理器的逻辑，从而实现不同的策略。

使用 render props：render props 是一种组件间通信的方式，通过 render 方法来将组件的状态和逻辑传递给子组件。可以通过 render props 来封装事件处理器的逻辑，从而实现不同的策略。

在 React 中，策略模式的实现方式是非常灵活的，开发者可以根据实际需求来选择不同的实现方式。通过使用策略模式来实现组件的事件处理，可以使组件的行为更加灵活和可扩展，使得程序的逻辑更加清晰，易于维护。

观察者模式
---
##### 应用场景

Spring Event是Spring框架中的一个事件机制，用于实现事件的发布和监听，可以用于实现以下功能：

业务解耦：通过事件机制，可以将业务逻辑解耦，将事件的发布和监听分离，提高代码的可维护性和可扩展性。

事件驱动编程：通过事件机制，可以实现事件驱动编程，将事件作为驱动器，根据事件的发生来触发相应的业务逻辑，提高代码的响应速度和性能。

业务扩展：通过事件机制，可以实现业务的扩展，当业务逻辑发生变化时，只需要新增或修改相应的事件监听器，而不需要修改原有的业务逻辑，提高代码的可维护性和可扩展性。

事务管理：通过事件机制，可以实现事务的管理，当事件发生异常时，可以通过事件机制来实现事务的回滚和异常处理，提高代码的可靠性和稳定性。

监控和统计：通过事件机制，可以实现业务的监控和统计，当事件发生时，可以通过事件机制来触发相应的监控和统计逻辑，提高代码的可观测性和可维护性。

总之，Spring Event是一个非常有用的事件机制，可以用于实现业务解耦、事件驱动编程、业务扩展、事务管理、监控和统计等功能，提高代码的可维护性、可扩展性、可靠性、可观测性和性能

##### 具体实现

对接CRM系统的会员中心 用户在商城的下单或者评价商品等动作 触发会员任务后 

使用SpringEvent+自定义线程池 实现事件监听 并异步通知CRM系统

AsyncEventConfig定义一个线程池来异步处理监听到的事件

```java
@EnableAsync
@Configuration
public class AsyncEventConfig {

    @Bean(name = "asyncEventExecutor")
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(5);
        executor.setThreadNamePrefix("AsyncEventExecutor-");
        executor.initialize();
        return executor;
    }
}
```

AbstractEventHandler作为抽象类定义了处理事件的方法 

在方法上加上注解@EventListener实现事件监听，以及注解@Async("asyncEventExecutor")实现异步处理事件

```java
@Slf4j
public class AbstractEventHandler<T extends ApplicationEvent> {

    @Autowired
    public TkService tkService;

    @EventListener
    @Async("asyncEventExecutor")
    public void handleEvent(T event) {
        log.debug("handleMyEvent:{}", event);
    }
}
```

以会员中心的会员任务-用户下单后 评价配件商品为例

我们定义了一个EvaluateAccessoryEvent的事件 继承ApplicationEvent 封装请求参数

```java
/**
 * 商品评价（配件or小件）事件
 */
@Getter
@Setter
public class EvaluateAccessoryEvent extends ApplicationEvent {

    /**
     * 用户token
     */
    private String token;

    /**
     * 订单ID
     */
    private String orderId;

    /**
     * 商品ID
     */
    private Integer goodsId;

    /**
     * 订单商品实付金额
     */
    private BigDecimal orderGoodsPaymentAmount;


    public EvaluateAccessoryEvent(Object source) {
        super(source);
    }

}
```

前端调用后端评价商品接口后 后端评价商品接口在返回success前调用了CrmEventService的sendEvaluateAccessoryEvent方法

方法内applicationEventPublisher将EvaluateAccessoryEvent事件进行发送

```java
@Slf4j
@Service
public class CrmEventService {

    @Autowired
    private ApplicationEventPublisher applicationEventPublisher;

    @Autowired
    private ReturnMoneyDao returnMoneyDao;

    @Autowired
    private OrderBaseDao orderBaseDao;

    @Autowired
    private TkService tkService;
    
    /**
     * 评价配件商品后发送消息给CRM
     *
     * @param token
     */
    public void sendEvaluateAccessoryEvent(String token, String orderId, Integer goodsBaseId, BigDecimal orderGoodsPaymentAmount) {
        EvaluateAccessoryEvent evaluateAccessoryEvent = new EvaluateAccessoryEvent(this);
        evaluateAccessoryEvent.setToken(token);
        evaluateAccessoryEvent.setGoodsId(goodsBaseId);
        evaluateAccessoryEvent.setOrderId(orderId);
        evaluateAccessoryEvent.setOrderGoodsPaymentAmount(orderGoodsPaymentAmount);
        applicationEventPublisher.publishEvent(evaluateAccessoryEvent);
    }
        
}    
```

我们实现一个EvaluateAccessoryEventHandler的事件处理器 继承了AbstractEventHandler

在泛型上指定EvaluateAccessoryEvent 重写了handleEvent方法 指定入参EvaluateAccessoryEvent

即可监听EvaluateAccessoryEvent事件并异步处理通知CRM

```java
/**
 * 商品评价（配件or小件）事件处理
 */
@Component
@Slf4j
public class EvaluateAccessoryEventHandler extends AbstractEventHandler<EvaluateAccessoryEvent> {

    @Override
    public void handleEvent(EvaluateAccessoryEvent event) {
        String token = event.getToken();
        String userCenterUserId = tkService.getUserCenterUserId(token);
        if (StringUtils.isBlank(userCenterUserId)) {
            log.error("EvaluateAccessoryEventHandler Failure, userCenterUserId Don't Exist, token :{}", token);
            return;
        }

        MemberTaskDTO memberTaskDTO = new MemberTaskDTO();
        memberTaskDTO.setUserId(userCenterUserId);
        memberTaskDTO.setOrderId(event.getOrderId());
        memberTaskDTO.setChangeType(CRMChangeType.ADD.code());
        memberTaskDTO.setTaskType(MemberTaskTypeEnum.EVALUATE_ACCESSORY.code());
        tkService.sendMsgToCRM(memberTaskDTO);
    }

}
```

使用Spring Event + 自定义线程池

将添可电器商城评价商品 和 CRM会员中心-用户任务-评价商品两个的业务功能进行解耦和代码分离

在不影响添可电器商城评价商品的接口响应速度的前提下 提高了评价商品功能的可维护性和可扩展性

##### 观察者模式在Vue中的使用:双向绑定

Vue 通过观察者模式实现了数据的双向绑定功能。

当使用 Vue 开发应用时，可以使用 Vue 提供的数据绑定语法，在模板中绑定数据，并且当数据发生改变时，模板会自动响应式更新。

Vue 内部实现了一个观察者系统，当数据发生变化时，观察者会自动更新 DOM，使得应用的显示与数据保持一致。

具体来说，Vue 通过使用 Object.defineProperty 或 ES6 的 Proxy 对数据对象进行监听，当数据对象的属性发生变化时，观察者会自动更新 DOM，从而实现了数据的响应式更新。

通过这种方式，Vue 实现了数据与模板的双向绑定，使得应用的数据和显示的内容保持同步，极大地方便了开发者的开发工作。

此外，React 的组件状态和属性的变化都可以通过观察者模式来实现。组件状态和属性的变化可以被视为事件，组件可以根据事件来进行状态的更新和视图的重新渲染。


状态模式
---

##### 应用场景

状态模式是一种行为型设计模式，它允许对象在内部状态发生改变时改变它的行为，从而使对象看起来像是改变了它的类。状态模式适用于以下场景：

对象的行为取决于它的状态，而且它的状态可能在运行时发生改变，可以使用状态模式来实现。

对象的行为包含大量的条件语句，而且这些条件语句依赖于对象的状态，可以使用状态模式来将这些条件语句转换为状态类。

对象的状态转换比较复杂，而且包含大量的条件语句，可以使用状态模式来将状态转换逻辑封装在状态类中，从而简化代码。

对象的状态转换需要在运行时动态地进行，可以使用状态模式来实现。

对象的状态转换需要在不同的状态下执行不同的行为，可以使用状态模式来实现。

总之，状态模式适用于需要将对象的状态和行为进行分离，并且需要在运行时动态地改变对象的行为的场景。它可以使得对象的状态转换逻辑更加清晰，代码更加简洁，同时也提高了代码的可维护性和可扩展性。

##### 具体实现

使用Spring官方提供的Spring StateMachine 处理订单状态

在pom文件中引入spring-statemachine-core依赖，

spring-statemachine-redis包是对状态机进行持久化，以及解决分布式数据同步问题

```java
        <!-->Spring状态机的依赖包<!-->
        <dependency>
            <groupId>org.springframework.statemachine</groupId>
            <artifactId>spring-statemachine-core</artifactId>
            <version>2.1.3.RELEASE</version>
        </dependency>
        <!-->Spring状态机Redis持久化的依赖包<!-->
        <dependency>
            <groupId>org.springframework.statemachine</groupId>
            <artifactId>spring-statemachine-redis</artifactId>
            <version>1.2.9.RELEASE</version>
        </dependency>
```

OrderState定义订单的状态

```java
/**
 * 订单状态枚举
 */
public enum OrderState {
    /**
     * 待支付
     */
    ORDER_WAIT_PAY,

    /**
     * 待发货
     */
    ORDER_WAIT_SEND,

    /**
     * 待收货
     */
    ORDER_WAIT_RECEIVE,
    /**
     * 订单完成
     */
    ORDER_FINISH,

    ;
}
```

OrderStateChangeAction定义订单流程事件

```java
public enum OrderStateChangeAction {

    /**
     * 支付操作 触发后 待支付-》待发货
     */
    PAY_ORDER,

    /**
     * 发货操作 触发后 待发货-》待收货
     */
    SEND_ORDER,

    /**
     * 收货操作 触发后 待收货-》订单完成
     */
    RECEIVE_ORDER,

    ;
}
```

OrderStateMachineConfig继承StateMachineConfigurerAdapter

重写StateMachineConfigurerAdapter的configure方法 配置状态机的初始状态和状态转化的触发事件

以及Redis的持久化配置

```java
@Configuration
@EnableStateMachine(name = "orderStateMachine")
public class OrderStateMachineConfig extends StateMachineConfigurerAdapter<OrderState, OrderStateChangeAction> {

    @Autowired
    private RedisConnectionFactory redisConnectionFactory;

    @Override
    public void configure(StateMachineStateConfigurer<OrderState, OrderStateChangeAction> states) throws Exception {
        //初始化状态 待支付
        states.withStates().initial(OrderState.ORDER_WAIT_PAY)
                .states(EnumSet.allOf(OrderState.class));
    }

    @Override
    public void configure(StateMachineTransitionConfigurer<OrderState, OrderStateChangeAction> transitions) throws Exception {
        //订单状态转化
        transitions
                .withExternal().source(OrderState.ORDER_WAIT_PAY)
                .target(OrderState.ORDER_WAIT_SEND)
                .event(OrderStateChangeAction.PAY_ORDER) //通过PAY_ORDER事件将待支付改为待发货
                .and()
                .withExternal().source(OrderState.ORDER_WAIT_SEND)
                .target(OrderState.ORDER_WAIT_RECEIVE)
                .event(OrderStateChangeAction.SEND_ORDER)//通过SEND_ORDER事件将待发货改为待收货
                .and()
                .withExternal().source(OrderState.ORDER_WAIT_RECEIVE)
                .target(OrderState.ORDER_FINISH)
                .event(OrderStateChangeAction.RECEIVE_ORDER)//通过ORDER_FINISH事件将待收货改为订单完成
                ;
    }

    /**
     * 状态机redis持久化
     * @return RedisStateMachinePersister
     */
    @Bean
    //@Bean("stateMachineRedisPersister")
    public RedisStateMachinePersister<OrderState, OrderStateChangeAction> getRedisPersister() {
        RedisStateMachineContextRepository<OrderState, OrderStateChangeAction> repository
                = new RedisStateMachineContextRepository<>(redisConnectionFactory);
        RepositoryStateMachinePersist<OrderState, OrderStateChangeAction> persist
                = new RepositoryStateMachinePersist<>(repository);
        return new RedisStateMachinePersister<>(persist);
    }


}
```

OrderStateListener对状态转化时进行监听

```java
@Component
@WithStateMachine(name = "orderStateMachine")
public class OrderStateListener {

    @Autowired
    private RedisTemplate<String, String> stringStringRedisTemplate;

    /**
     * 监听待支付到待发货到事件
     * @param message
     * @return
     */
    @OnTransition(source = "ORDER_WAIT_PAY", target = "ORDER_WAIT_SEND")
    public boolean payToSend (Message<OrderStateChangeAction> message) {
        //获取订单状态， 判断当前订单状态是否为待支付
        Order order = (Order) message.getHeaders().get("order");
        if (order.getOrderState() != OrderState.ORDER_WAIT_PAY) {
            throw new UnsupportedOperationException("Order State Error!");
        }

        //支付逻辑省略 微信 支付宝

        // 支付成功后修改 订单状态为待发货 并更新redis缓存
        order.setOrderState(OrderState.ORDER_WAIT_SEND);
        return true;
    }

    @OnTransition(source = "ORDER_WAIT_SEND", target = "ORDER_WAIT_RECEIVE")
    public boolean sendToReceive (Message<OrderStateChangeAction> message) {
        //待发货-》已发货
        return true;
    }

    @OnTransition(source = "ORDER_WAIT_RECEIVE", target = "ORDER_FINISH")
    public boolean receiveToFinish (Message<OrderStateChangeAction> message) {
        //已发货-》订单完成
        return true;
    }

}

```
OrderService中支付成功后回调方法内封装Message发送给OrderStateListener

```java
@Service
public class OrderService {

    public static final String stateMachineId = "orderStateMachine";

    @Autowired
    private StateMachineFactory<OrderState, OrderStateChangeAction> orderStateMachineFactory;

    @Autowired
    private RedisStateMachinePersister<OrderState, OrderStateChangeAction>  redisStateMachinePersister;

    @Autowired
    private RedisTemplate<String, String> stringStringRedisTemplate;

    /**
     * 支付回调
     * @param orderId 订单id
     * @return Order
     */
    public Order pay (String orderId) {
        Order order = getOrder();
        //包装订单状态变更message 附带订单操作pay_order
        Message<OrderStateChangeAction> message = MessageBuilder.withPayload(OrderStateChangeAction.PAY_ORDER)
                .setHeader("order", order).build();

        //传递给状态机
        if (changeStateAction(message, order)) {
            return order;
        }
        return null;
    }


    /**
     * 发送事件
     * @param message
     * @param order
     * @return
     */
    public boolean changeStateAction(Message<OrderStateChangeAction> message, Order order) {
        StateMachine<OrderState, OrderStateChangeAction> stateMachine = null;

        try {
            String key = order.getOrderId() + "STATE";
            stateMachine = orderStateMachineFactory.getStateMachine(stateMachineId);
            //启动状态机
            stateMachine.start();
            //从redis读取状态机 缓存key（自定义）
            redisStateMachinePersister.restore(stateMachine, key);
            //发送给OrderStateListener
            boolean result = stateMachine.sendEvent(message);
            //将更改完订单状态的 状态机 存储到 redis缓存
            redisStateMachinePersister.persist(stateMachine, key);
            return result;

        }catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (stateMachine != null) {
                //停止状态机
                stateMachine.stop();
            }
        }
        return false;
    }
    
    private Order getOrder() {
        //从Redis获取订单信息
    }
}

```

在状态机中 最重要到是根据实际业务来定义状态类型和状态流转事件到类型，我们可以发现

状态机都是有状态的（Stateful）的，有状态意味着多线程并发情况下如果是单个实例就容易出现线程安全问题。

在如今的普遍分布式多线程环境中，你就不得不每次一个请求就创建一个状态机实例。

但问题来了：一旦碰到某些状态机它的构建过程很复杂，如果当下QPS又很高话，往往会造成系统的性能瓶颈。

Spring官方提供到stateMachine框架存在着上述问题，在此有兴趣的朋友看下阿里开源的状态机框架cola-statemachine：

阿里巴巴的cola-statemachine框架和Spring官方的Spring stateMachine框架都是基于状态机的框架，它们都可以用于实现状态机的建模和实现。它们的主要区别在于以下几个方面：

功能特性：cola-statemachine框架相比Spring stateMachine框架，提供了更加丰富的功能特性，例如支持状态机的嵌套、支持状态机的分布式部署、支持状态机的持久化和恢复等。这些功能特性可以满足更加复杂的业务场景，提高了框架的可用性和可扩展性。

性能和可靠性：cola-statemachine框架相比Spring stateMachine框架，具有更高的性能和可靠性。它采用了高性能的状态机引擎，可以支持高并发和高吞吐量的业务场景，同时也具有更好的容错和恢复能力。

易用性和可扩展性：cola-statemachine框架相比Spring stateMachine框架，具有更好的易用性和可扩展性。它提供了更加简洁和易用的API，可以快速地实现状态机的建模和实现，同时也支持自定义状态机的扩展和定制。

总之，cola-statemachine框架相比Spring stateMachine框架，具有更加丰富的功能特性、更高的性能和可靠性、更好的易用性和可扩展性，可以满足更加复杂的业务场景，是一个更加优秀的状态机框架。

原型模式
---

##### 应用场景

大量相似对象的创建：当需要创建大量的相似对象，但创建对象的过程比较耗时时，可以使用原型模式，先创建一个对象作为原型，然后通过复制原型对象的方式来创建新对象，避免重复创建相似的对象，提高创建对象的效率。

隐藏对象的创建细节：当创建对象的过程比较复杂，需要进行很多复杂的初始化操作时，可以使用原型模式，将对象的创建过程隐藏在原型对象的内部，对外只提供一个复制原型的方法，将对象的创建细节隐藏起来，简化了对象的创建过程。

动态配置对象：当需要动态配置对象的属性时，可以使用原型模式，先创建一个原型对象，然后根据需要动态地修改原型对象的属性，然后复制原型对象创建新对象。这样可以极大地方便对象的配置。

保护对象的数据安全：当需要在多个地方使用同一个对象时，但这个对象的数据需要保护，避免被其他地方修改时，可以使用原型模式，将对象的数据复制到新对象中，通过复制对象来避免数据被修改。

用于框架开发：在框架开发中，原型模式被广泛使用，例如Spring框架就通过原型模式创建Bean对象，然后根据需要动态地修改Bean对象的属性，最后将Bean对象注入到容器中，提供给用户使用。

##### 具体实现

在群发短信的场景下，如果需要大量的用户，如成千上万的用户，都需要进行短信通知。就可以使用原型模式

SmsTemplate定义了短信模版 一般配置在数据库中

```java
/**
 * 短信模版 包含了模版id 和模版内容
 */
public class SmsTemplate {

    /**
     * 短信模版id
     */
    private String templateId;

    /**
     * 短信模版内容
     */
    private String templateContent;

    /**
     * 短信类型 1-营销短信 2-通知短信
     */
    private Integer type;


    public SmsTemplate(String templateId, Integer type,  String templateContent) {
        this.templateId = templateId;
        this.templateContent = templateContent;
        this.type = type;
    }

    public SmsTemplate() {
    }

    public String getTemplateId() {
        return templateId;
    }

    public void setTemplateId(String templateId) {
        this.templateId = templateId;
    }

    public String getTemplateContent() {
        return templateContent;
    }

    public void setTemplateContent(String templateContent) {
        this.templateContent = templateContent;
    }

    public Integer getType() {
        return type;
    }

    public void setType(Integer type) {
        this.type = type;
    }
}

```
SmsRequest封装了第三方平台sdk或者接口的数据对象 因为需要创建大量的对象 所以在SmsRequest对象中实现了Cloneable接口

并重写了clone方法

```java
/**
 * 请求第三方平台对象 注意 必须 实现Cloneable 重写clone方法
 */
public class SmsRequest implements Cloneable{

    /**
     * 用户手机
     */
    private Long userPhone;

    /**
     * 短信模版
     */
    private String templateContent;

    /**
     * 短信类型 1-营销短信 2-通知短信
     */
    private Integer type;


    public Long getUserPhone() {
        return userPhone;
    }

    public void setUserPhone(Long userPhone) {
        this.userPhone = userPhone;
    }

    public Integer getType() {
        return type;
    }

    public void setType(Integer type) {
        this.type = type;
    }

    public String getTemplateContent() {
        return templateContent;
    }

    public void setTemplateContent(String templateContent) {
        this.templateContent = templateContent;
    }

    public SmsRequest(Long userPhone, Integer type,  String templateContent) {
        this.userPhone = userPhone;
        this.type = type;
        this.templateContent = templateContent;
    }

    /**
     * 替换短信内容
     * @param variables
     */
    public void replaceVariables (Map<String, String> variables) {
        String content = this.templateContent;
        for (Map.Entry<String, String> entry : variables.entrySet()) {
            String variablesName = entry.getKey();
            String variablesValue = entry.getValue();
            content = content.replace("{" + variablesName + "}", variablesValue);
        }
        this.templateContent =  content;
    }

    @Override
    protected SmsRequest clone() throws CloneNotSupportedException {
        SmsRequest clone = null;
        try {
            //使用该方法克隆原型对象
            clone = (SmsRequest) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return clone;
    }

    @Override
    public String toString() {
        return "SmsRequest{" +
                "userPhone=" + userPhone +
                ", templateContent='" + templateContent + '\'' +
                ", type=" + type +
                '}';
    }
}
```

在SmsService中sendSms方法中 传入短信模版对象和要发送的用户信息和内容的map

sendSms在遍历用户信息前会创建SmsRequest类型的一个原型对象

调用第三方平台前 for循环的每次遍历用户数据时都会更具SmsRequest类型的一个原型对象克隆出一个新的对象

节省了创建SmsRequest的事件 因为如果要发给5000个用户 就需要创建5000个SmsRequest对象

使用原型模式就可以节省创建对象的时间

```java
public class SmsService {

    private final static String NAME = "name";

    private final static String COUPON = "coupon";

    public static void main(String[] args) throws CloneNotSupportedException {
        /**
         * 获取短信模版
         */
        SmsTemplate smsTemplate = new SmsTemplate("1", 1,
                "尊敬到{name}先生/女士，您的{coupon}元优惠券已发放到您到券包中，请登录添可小程序查看。");

        /**
         * 获取要发送的用户信息variablesMap 例如从数据库中查询用户手机号等
         */
        Map<String, Map<String, String>> variablesMap  = new HashMap<>();
        Map<String, String> valueMap = new HashMap<>();
        valueMap.put(NAME, "爱因斯坦");
        valueMap.put(COUPON, "8");
        variablesMap.put("18866665555", valueMap);


        Map<String, String> valueMap2 = new HashMap<>();
        valueMap2.put(NAME, "牛顿");
        valueMap2.put(COUPON, "10");
        variablesMap.put("18866664444", valueMap2);

        sendSms(variablesMap, smsTemplate);
    }

    /**
     *
     * @param variablesMap key 手机号 value 占位符和替换值到键值对
     * @param template 短信模版
     * @throws CloneNotSupportedException
     */
    public static void sendSms (Map<String, Map<String, String>> variablesMap, SmsTemplate template) throws CloneNotSupportedException {
        String templateContent = template.getTemplateContent();
        SmsRequest prototype = new SmsRequest(null, template.getType(), templateContent);//创建原型对象
        for (Map.Entry<String, Map<String, String >> entry : variablesMap.entrySet()) {
            String phoneNumber = entry.getKey();
            Map<String, String> variables = entry.getValue();
            SmsRequest request = prototype.clone();//克隆原型对象
            request.replaceVariables(variables);
            request.setUserPhone(Long.valueOf(phoneNumber));
            sendSms(request);
        }

    }

    private static void sendSms (SmsRequest smsRequest) {
        System.out.println("sendSms" + smsRequest.toString());
    }


}
```
组装的数据结果如下：

```java
    Connected to the target VM, address: '127.0.0.1:55121', transport: 'socket'
    sendSmsSmsRequest{userPhone=18866665555, templateContent='尊敬到爱因斯坦先生/女士，您的8元优惠券已发放到您到券包中，请登录添可小程序查看。', type=1}
    sendSmsSmsRequest{userPhone=18866664444, templateContent='尊敬到牛顿先生/女士，您的10元优惠券已发放到您到券包中，请登录添可小程序查看。', type=1}
    Disconnected from the target VM, address: '127.0.0.1:55121', transport: 'socket'
```

在该案例中，使用了浅拷贝的方式，浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归复制引用对象。

而深拷贝的话得到的时一份完完全全的对立对象。所以如果使用深拷贝的话，更加耗时，更加耗内存。

如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，

就可能由数据被修改的风险，就会变得复杂，所以一般在操作大量数据非常感觉耗时时，推荐浅拷贝来处理。

责任链模式
---

##### 应用场景

请求的处理需要多个对象协作完成：当一个请求需要多个对象协作完成，且处理对象的顺序比较固定时，可以使用责任链模式。例如，一个网购系统，需要进行多个验证，包括用户信息验证、订单验证、库存验证、支付验证等等，每个验证可以看作是责任链中的一个处理节点，处理节点之间的顺序是固定的，可以使用责任链模式来实现。

请求的处理需要动态添加、修改、删除处理节点：当系统的请求处理方式需要动态添加、修改、删除处理节点时，可以使用责任链模式。例如，一个日志系统，可以动态添加、修改、删除日志记录的处理节点，可以使用责任链模式来实现。

处理节点之间需要解耦：当处理节点之间需要解耦时，可以使用责任链模式。例如，一个服务器请求处理系统，需要处理来自不同客户端的请求，处理节点需要解耦，可以使用责任链模式来实现。

处理节点的顺序需要动态调整：当处理节点的顺序需要动态调整时，可以使用责任链模式。例如，一个行程管理系统，需要根据不同的用户类型和行程类型，动态调整行程处理的顺序，可以使用责任链模式来实现。

避免请求发送者与处理者之间的耦合：当请求发送者与处理者之间需要松耦合时，可以使用责任链模式。例如，一个日志系统，需要将日志记录发送给多个处理器，发送者与处理者之间需要松耦合，则可以使用责任链模式来实现。

##### 具体实现

在新版添可电器商城中，创建订单的业务功能就使用了责任链模式

OrderProcess接口定义处理订单的方法

```java

package org.project.order.service.order;


public interface OrderProcess {

    /**
     * 开始处理
     *
     * @param saveOrderVo 原始保存数据
     * @param orderList   订单处理数据
     * @param chain       链条
     */
    void doProcess(SaveOrderVo saveOrderVo, List<OrderProcessDataDto> orderList, OrderProcessChain chain);
}
```

接着根据创建订单逻辑，来实现OrderProcess接口

如BeforeOrderProcess类实现创建订单前置处理

```java
@Slf4j
public class BeforeOrderProcess implements OrderProcess {

    @Override
    public void doProcess(SaveOrderVo saveOrderVo, final List<OrderProcessDataDto> orderList, OrderProcessChain chain) {
        //下单事务此处开启
        TransactionTemplate transactionTemplate = WebUtil.getBean(TransactionTemplate.class);
        transactionTemplate.executeWithoutResult(status -> {
            try {
                //获取并删除购物车数据
                List<UserCartEntity> userCartEntities = WebUtil.getBean(UserCartService.class).queryAndRemoveUserCarts(saveOrderVo.getCartIds());
                //订单商品列表
                List<OrderGoodsProcessDataDto> orderGoodsList = null;
                if (!CollectionUtils.isEmpty(saveOrderVo.getOrderGoodsList())) {
                    //用户传入商品不为空
                    orderGoodsList = convertForSaveOrderGoods(saveOrderVo.getOrderGoodsList());
                } else if (!CollectionUtils.isEmpty(userCartEntities)) {
                    //购物车存在商品
                    orderGoodsList = convertForCart(userCartEntities);
                }
                AssertUtil.state(!CollectionUtils.isEmpty(orderGoodsList), new I18nBusinessException("BeforeOrderProcess.noOrderGoods"));
                assert orderGoodsList != null;
                //补充下单商品数据
                fillOrderGoodsProcessData(orderGoodsList);
                //补充组合商品数据信息
                fillCombinationGoods(orderGoodsList);
                //开始拆单，店铺订单商品列表字典项
                splitOrderAndFillExtInfo(saveOrderVo, orderList, orderGoodsList);
                //获取redis模板
                StringRedisTemplate redisTemplate = WebUtil.getBean(StringRedisTemplate.class);
                //需要保存进redis中的信息
                Map<String, String> multiSaveMap = new HashMap<>();
                orderList.forEach(orderProcessData -> multiSaveMap.put(CacheKeyConstant.ORDER_CREATING_PREFIX + orderProcessData.getOrderId(), DateUtil.format(DateUtil.getNowDate(), DateUtil.STANDARD_FORMATTER)));
                try {
                    //保存订单号进入redis表示正在创建订单
                    redisTemplate.opsForValue().multiSet(multiSaveMap);
                    //进入下一个链条
                    chain.doProcess(saveOrderVo, orderList);
                } finally {
                    //删除redis正在创建订单的标识
                    redisTemplate.delete(multiSaveMap.keySet());
                }
            } catch (Exception e) {
                status.setRollbackOnly();
                throw e;
            }
        });
        //发送下单成功通知事件
        WebUtil.getApplicationContext().publishEvent(new OrderSuccessEvent(orderList));
    }

    /**
     * 购物车实体 -> 订单商品处理数据
     *
     * @param userCartEntities 购物车实体列表
     * @return 订单商品处理数据列表
     */
    private List<OrderGoodsProcessDataDto> convertForCart(List<UserCartEntity> userCartEntities) {
        //业务代码省略...
    }

    /**
     * 用户商品实体 -> 订单商品处理数据
     *
     * @param goodsList 商品列表
     * @return 订单商品处理数据列表
     */
    private List<OrderGoodsProcessDataDto> convertForSaveOrderGoods(List<SaveOrderGoodsVo> goodsList) {
        //业务代码省略...
    }

    /**
     * 填充订单商品处理数据
     *
     * @param orderGoodsList 订单商品列表
     */
    private void fillOrderGoodsProcessData(List<OrderGoodsProcessDataDto> orderGoodsList) {
        //业务代码省略...
    }

    /**
     * 补充组合商品数据信息
     *
     * @param orderGoodsList 订单商品列表
     */
    private void fillCombinationGoods(List<OrderGoodsProcessDataDto> orderGoodsList) {
        //业务代码省略...
    }

    /**
     * 开始拆单，并补充订单附加数据
     *
     * @param saveOrderVo    保存订单参数
     * @param orderList      订单列表
     * @param orderGoodsList 订单商品列表
     */
    private void splitOrderAndFillExtInfo(SaveOrderVo saveOrderVo, List<OrderProcessDataDto> orderList, List<OrderGoodsProcessDataDto> orderGoodsList) {
        //业务代码省略...
    }
}
```

除了BeforeOrderProcess（订单前置数据处理）外，还有DeductStockOrderProcess（扣减商品库存），ActivityOrderProcess（活动处理），
CouponOrderProcess（优惠券处理），ShippingFeeOrderProcess（运费处理），IntegralOrderProcess（积分处理），
ECardOrderProcess（E卡处理），OrderPriceCalculateOrderProcess（订单金额计算处理）， FinishOrderProcess（最终保存订单处理）
共计8个process，我们需要将这8个process组装成一个链条放入责任链中，在创建订单后，触发责任链，依次处理这8个业务逻辑。

##### 组装责任链

在项目resources目录下建一个META.services目录

在该目录下创建一个名为org.project.order.service.order.OrderProcess的文件

内容为

    org.project.order.service.order.process.BeforeOrderProcess ##订单前置数据处理
    org.project.order.service.order.process.DeductStockOrderProcess ##扣减商品库存
    org.project.order.service.order.process.ActivityOrderProcess ##活动处理
    org.project.order.service.order.process.CouponOrderProcess ##优惠券处理
    org.project.order.service.order.process.ShippingFeeOrderProcess ##运费处理
    org.project.order.service.order.process.IntegralOrderProcess ##积分处理
    org.project.order.service.order.process.ECardOrderProcess ##E卡处理
    org.project.order.service.order.process.OrderPriceCalculateOrderProcess ##订单金额计算处理
    org.project.order.service.order.process.FinishOrderProcess ##最终保存订单处理

OrderProcessChain接口定义责任链

```java
public interface OrderProcessChain {

    /**
     * 开始处理
     *
     * @param saveOrderVo 原始保存订单数据
     * @param orderList   订单处理数据
     */
    void doProcess(SaveOrderVo saveOrderVo, List<OrderProcessDataDto> orderList);
}

```

OrderProcessHandler创建下单方法doOrder，和内部类DefaultOrderProcessChain来组装上面8个订单Process

```java
@Component
public class OrderProcessHandler implements InitializingBean {

    /**
     * 订单处理链条
     */
    private OrderProcessChain orderProcessChain;

    /**
     * 开始下单
     *
     * @param orderList 订单处理数据
     */
    public void doOrder(SaveOrderVo saveOrderVo, List<OrderProcessDataDto> orderList) {
        orderProcessChain.doProcess(saveOrderVo, orderList);
    }

    /**
     * 默认订单处理链条
     */
    private static class DefaultOrderProcessChain implements OrderProcessChain {

        /**
         * 索引字段
         */
        private final int index;

        /**
         * 订单处理类列表
         */
        private final List<OrderProcess> orderProcessList;

        DefaultOrderProcessChain(List<OrderProcess> processList) {
            this.orderProcessList = processList;
            this.index = 0;
        }

        private DefaultOrderProcessChain(DefaultOrderProcessChain parent, int index) {
            this.orderProcessList = parent.getOrderProcessList();
            this.index = index;
        }

        public List<OrderProcess> getOrderProcessList() {
            return orderProcessList;
        }

        @Override
        public void doProcess(SaveOrderVo saveOrderVo, List<OrderProcessDataDto> orderList) {
            if (this.index < orderProcessList.size()) {
                OrderProcess orderProcess = orderProcessList.get(this.index);
                DefaultOrderProcessChain chain = new DefaultOrderProcessChain(this, this.index + 1);
                orderProcess.doProcess(saveOrderVo, orderList, chain);
            }
        }
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        ServiceLoader<OrderProcess> serviceLoader = ServiceLoader.load(OrderProcess.class);
        List<OrderProcess> processList = new ArrayList<>();
        for (OrderProcess orderProcess : serviceLoader) {
            processList.add(orderProcess);
        }
        if (CollectionUtils.isEmpty(processList)) {
            return;
        }
        //组装链条
        orderProcessChain = new DefaultOrderProcessChain(processList);
    }
}
```
在Bean的初始化阶段会调用afterPropertiesSet方法，使用ServiceLoader.load方法解析加载我们最开始定义在resources.META-INF.services下面的org.project.order.service.order.OrderProcess文件

这是基于SPI思想 通过JDK自带的ServiceLoader来扫描配置信息来加载业务实现。将我们的8个Process类进行加载实例化，最终放在我们的orderProcessChain的orderProcessList数组中

用户下单接口只需要注入OrderProcessHandler并调用doOrder方法，即可开始处理下单责任链的8个业务流程

我们回到BeforeOrderProcess类中，可以看到这样一行代码

```java
                    //进入下一个链条
                    chain.doProcess(saveOrderVo, orderList);
```

因为我们在DefaultOrderProcessChain中重写了doProcess方法，所以BeforeOrderProcess在处理完逻辑后，调用chain.doProcess(),

进入的就是DefaultOrderProcessChain中的doProcess方法，在方法内根据获取当前Process的下标，然后加1进入下一个Process的doProcess方法

在8个Process中都会在方法结束时doProcess，传递责任链并调用责任链中下一个Process，共同来完成创建订单的流程。

一直到this.index < orderProcessList.size() == false 结束整个责任链的处理流程。

```java
        @Override
        public void doProcess(SaveOrderVo saveOrderVo, List<OrderProcessDataDto> orderList) {
            if (this.index < orderProcessList.size()) {
                OrderProcess orderProcess = orderProcessList.get(this.index);
                DefaultOrderProcessChain chain = new DefaultOrderProcessChain(this, this.index + 1);
                orderProcess.doProcess(saveOrderVo, orderList, chain);
            }
        }

        private DefaultOrderProcessChain(DefaultOrderProcessChain parent, int index) {
                this.orderProcessList = parent.getOrderProcessList();
                this.index = index;
                }
```

至此使用责任链来实现整个创建订单的流程就结束了。


写在最后
---
在本篇中分别在线程隔离创建线程池使用了双重检查单例模式，购物车or订单计算商品价格使用了策略模式，轻量化限流使用了代理模式，

CRM会员中心-会员任务使用了观察者模式，订单状态流转使用了状态模式，群发短信使用了原型模式，创建订单流程使用了责任链模式。

也通过代理模式引出滥用设计模式触发实际生产环境出现的问题。

这几个设计模式的使用场景都提供的代码实现，其实在实际生产环境中，随着公司整体发展和活动策划运营的变化，我们的代码随着业务场景的迭代更新需要进行不断修改和重构。

在代码使用了设计模式需谨记一定要保持代码的可读性。业务代码不同于非业务代码，有很多定制化功能特有的逻辑代码,在业务复杂且设计复杂的情况下，如果没有相应的注释，不只是可读性，连可维护性也无法保证。

这些案例可能在不同的公司不同的产品不同的时期下并不是都可以通用的。介绍这些案例只希望在开发中给各位提供一些参考和思路。

如果后续我们在开发中想实践应用诸多设计模式的思想，在敲键盘写代码前，可以思考以下几点：

```markdown
确定模式适用的范围：设计模式并不是银弹，不是在所有场景下都适用，需要在具体场景中选择合适的设计模式来解决特定的问题。

考虑未来的变化：在使用设计模式时应当考虑未来的变化，避免设计死板，可以通过接口定义的方式来实现可扩展性，可以通过组合的方式来实现对象的灵活性。

保持简单：设计模式并不是为了让代码变得更复杂，应当保持简单，避免过度设计和过度使用设计模式。

在合适的时候使用：设计模式应当在合适的时候使用，在代码的架构和设计中应当避免使用过多的设计模式，以免代码复杂难以维护。

避免过度使用继承：在使用设计模式时应当避免过度使用继承，因为继承会导致类之间的紧耦合，应当尽量使用组合和委托来实现对象之间的关系。

保持代码的可读性和可维护性：在使用设计模式时应当保持代码的可读性和可维护性，应当遵循良好的编程规范和标准，使用清晰的变量名和方法名，避免使用过于复杂的代码结构。

```

