双重检查锁单例模式
---
##### 应用场景

双重检查单例模式是一种线程安全的单例模式实现方式，可以在实际生产中应用于需要保证全局唯一性的场景，例如：

数据库连接池：在一个应用中，可能需要多个线程同时访问数据库，为了避免每次访问数据库都需要创建新的连接，可以使用单例模式来创建数据库连接池，保证全局唯一性，提高数据库访问的效率。

日志记录器：在一个应用中，可能需要多个线程同时记录日志，为了避免日志记录器的实例被多个线程创建，可以使用单例模式来创建日志记录器，保证全局唯一性，避免日志记录的重复和混乱。

配置文件管理器：在一个应用中，可能需要多个线程同时访问配置文件，为了避免每次访问配置文件都需要创建新的实例，可以使用单例模式来创建配置文件管理器，保证全局唯一性，提高配置文件访问的效率。

需要注意的是，双重检查单例模式虽然可以保证线程安全，但是在一些特殊的场景下可能会出现问题，例如在多线程环境下，如果一个线程正在创建实例，而另一个线程同时访问了getInstance方法，可能会导致实例被创建多次。因此，在使用双重检查单例模式时，需要仔细考虑线程安全性和性能问题，确保能够满足实际需求。

##### 具体实现

使用双重检查单例创建一个线程池及注意事项

```java
/**
 * 双重检查锁单例模式中，使用volatile关键字来修饰单例对象的变量，是为了保证多线程环境下的可见性和有序性。
 *
 * 在双重检查锁单例模式中，第一次检查单例对象是否为null时，如果多个线程同时进入了这个判断语句，
 *
 * 那么它们都会认为单例对象为null，然后会进入同步代码块中，创建单例对象。
 *
 * 但是，如果没有使用volatile关键字来修饰单例对象的变量，那么在某个线程创建单例对象之后，其他线程可能无法立即看到这个变化，仍然会认为单例对象为null，
 *
 * 然后继续创建单例对象，这样就会创建多个实例，违背了单例模式的初衷。
 *
 * 使用volatile关键字来修饰单例对象的变量，可以保证在多线程环境下，单例对象的变化对其他线程是可见的，从而避免了创建多个实例的问题。
 *
 * 同时，volatile关键字还可以保证单例对象的创建是有序的，避免了指令重排的问题。
 */
public class DoubleCheckSingleton {

    private static volatile ThreadPoolTaskExecutor threadPoolTaskExecutor = null;

    public DoubleCheckSingleton () {
        System.out.println(Thread.currentThread().getName() + ":DoubleCheckSingleton");
    }

    public static ThreadPoolTaskExecutor getInstance() {
        if (threadPoolTaskExecutor == null) {
//            双重检查锁单例模式中，使用锁来保证线程安全，锁的对象是Singleton.class，而不是this对象，是因为this对象在多线程环境下是不安全的。
//
//            在单例模式中，单例对象是在类加载的时候就被创建出来的，因此锁的对象应该是类对象，而不是实例对象。
//
//            使用Singleton.class作为锁对象，可以保证在多线程环境下，只有一个线程可以进入同步代码块，创建单例对象。
//
//            而使用this对象作为锁对象，会出现多个实例的情况，因为在多线程环境下，每个线程都有自己的实例对象，锁的是自己的实例对象，无法保证只有一个线程可以进入同步代码块。
//
//            另外，使用Singleton.class作为锁对象，可以保证在类加载的时候就被初始化，避免了在多线程环境下出现多个实例的情况。
//
//            而使用this对象作为锁对象，需要在实例化之后才能使用，无法保证在实例化之前不会出现多个实例的情况。
            synchronized (DoubleCheckSingleton.class) {
                if (threadPoolTaskExecutor == null) {
                    ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
                    threadPoolTaskExecutor.setCorePoolSize(5);
                    threadPoolTaskExecutor.setMaxPoolSize(5);
                    threadPoolTaskExecutor.setThreadNamePrefix("AsyncEventExecutor-");
                    threadPoolTaskExecutor.initialize();
                    return threadPoolTaskExecutor;
                }
            }
        }
        return threadPoolTaskExecutor;
    }

    public static void main(String[] args) {
        ThreadPoolTaskExecutor instance = getInstance();
        instance.execute(new Runnable() {
            @Override
            public void run() {
                // 执行任务
            }
        });
    }
}

```

策略模式
---

##### 应用场景


##### 具体实现

添可电器商品功能：在购物车及提交订单时计算商品是否参加活动及最低价格

首先定义了一个计算商品价格到策略接口，这个接口定义了计算价格到方法和返回值，以及不同策略所属到活动类型

```java
/**
 * 活动商品计算价格
 */
public interface ActivityGoodsCalculatePriceStrategy {

    /**
     * 根据活动来计算商品价格
     * @param calculatePriceRequest 商品原价及数量等信息
     * @return CalculatePriceResponse
     */
    CalculatePriceResponse calculatePrice(CalculatePriceRequest calculatePriceRequest);

    /**
     * 获取活动类型
     * @return ActivityType
     */
    ActivityType getActivityType();
}
```

ActivityType作为枚举，定义不同到活动到类型枚举和活动名称 用于后端逻辑判断和返回前端使用

```java
public enum ActivityType {

    NORMAL(0,"不参加活动"),
    DISCOUNT(1,"满折活动"),

    ;
    private final Integer code;
    private final String message;

    ActivityType(Integer code, String message) {
        this.code = code;
        this.message = message;
    }

    public Integer getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }

    public static String getMessageByCode(Integer code) {
        if (null == code) {
            return null;
        }
        for (ActivityType value : values()) {
            if (value.getCode().equals(code)) {
                return value.message;
            }
        }
        return null;
    }

    public static ActivityType getByCode(Integer code) {
        if (null == code) {
            return null;
        }
        for (ActivityType value : values()) {
            if (value.getCode().equals(code)) {
                return value;
            }
        }
        return null;
    }
}
```
CalculatePriceRequest作为请求数据 包含了商品id，商品正常价格，商品数量（购物车和提交订单页面的商品数量）等数据

```java
/**
 * 计算商品价格请求数据
 */
@Data
public class CalculatePriceRequest {

    @ApiModelProperty("goods_common表id(SPU)")
    @NotNull
    private Long goodsCommonId;

    @ApiModelProperty("goods_base表id(SKU)")
    @NotNull
    private Long goodsBaseId;

    @ApiModelProperty("商品原价（正常价格）")
    @NotNull
    private BigDecimal originalPrice;

    @ApiModelProperty("商品数量")
    @NotNull
    private Integer quantity;

    /**
     * 活动类型 1-满折活动
     *
     * @see ActivityType
     */
    @ApiModelProperty("指定活动类型，如传入1代表只按满折活动来计算活动总价，即使商品参加其他活动且活动总价比满折活动低，依然按满折活动计算")
    @NotNull
    private Integer activityType;
}
```

CalculatePriceResponse封装了计算价格到结果，封装了是否参与活动 活动id 活动类型 活动说明 活动价

以及同一个商品有多件 有几件可以参与活动 有多少件不能参加活动 （例如限购活动中，只能有一件按活动价 其余按原价 按原价到商品可以使用优惠券）

```java
/**
 * 商品计算价格结果
 */
@Data
public class CalculatePriceResponse {

    @ApiModelProperty("活动ID")
    private Long activityId;

    @ApiModelProperty("参与活动的商品总价: 如满折活动：商品原价 * 参加活动的商品数量 * 折扣")
    private BigDecimal activityPrice;

    @ApiModelProperty("参与活动的商品单价: 如满折活动：商品原价 * 折扣。没有参加任何活动这里就是原价")
    private BigDecimal activityGoodsPrice;

    @ApiModelProperty("参与活动的商品数量")
    private Integer activityQuantity;

    @ApiModelProperty("未参与活动的商品数量")
    private Integer notJoinActivityQuantity;

    @ApiModelProperty("差价（参加活动的商品原总价 - 参与活动的商品总价）")
    private BigDecimal priceDifference;

    /**
     * 活动类型 1-满折活动
     *
     * @see ActivityType
     */
    @ApiModelProperty("活动类型 0-不参加活动，1-满折活动")
    private Integer activityType;

    @ApiModelProperty("活动详情描述,如：该商品满两件8折，三件5折")
    private String activityDesc;
}
```


AbstractActivityGoodsCalculatePriceStrategy实现了ActivityGoodsCalculatePriceStrategy接口，作为默认到计算商品价格的策略 

如果商品不参加任何活动，计算价格到逻辑就由AbstractActivityGoodsCalculatePriceStrategy处理

```java
/**
 * 不参与任何活动商品的计算价格策略
 */
@Slf4j
@Service
public class AbstractActivityGoodsCalculatePriceStrategy implements ActivityGoodsCalculatePriceStrategy {


    private static final ActivityType activityType = ActivityType.NORMAL;
    /**
     * 该商品任何活动都没参加
     *
     * @param calculatePriceRequest
     * @return
     */
    @Override
    public CalculatePriceResponse calculatePrice(CalculatePriceRequest calculatePriceRequest) {
        BigDecimal originalPrice = calculatePriceRequest.getOriginalPrice();
        Integer quantity = calculatePriceRequest.getQuantity();
        CalculatePriceResponse calculatePriceResponse = new CalculatePriceResponse();
        BigDecimal originalTotalPrice = originalPrice.multiply(BigDecimal.valueOf(quantity));
        calculatePriceResponse.setActivityPrice(originalTotalPrice);
        calculatePriceResponse.setActivityQuantity(0);
        calculatePriceResponse.setNotJoinActivityQuantity(quantity);
        calculatePriceResponse.setActivityType(activityType.getCode());
        //差价 （商品总价 - 参与活动的商品总价） 无活动参加 差价是0
        calculatePriceResponse.setPriceDifference(BigDecimal.ZERO);
        //参加活动后每个商品的单价 这里没有参加任何活动就是原价
        calculatePriceResponse.setActivityGoodsPrice(originalPrice);
        //不参加任何活动 设置为0
        calculatePriceResponse.setActivityId(0L);
        log.info("AbstractActivityGoodsCalculatePriceStrategy calculatePrice Result ：{}", JSONObject.toJSONString(calculatePriceResponse));
        return calculatePriceResponse;
    }

    @Override
    public ActivityType getActivityType() {
        return activityType;
    }
}

```

DiscountActivityStrategy继承了AbstractActivityGoodsCalculatePriceStrategy

如果如果商品参与了满折活动就由DiscountActivityStrategy处理，如果满折活动计算价格发生异常 就由AbstractActivityGoodsCalculatePriceStrategy处理

```java
/**
 * 参与满折活动商品的计算价格策略
 */
@Slf4j
@Service
public class DiscountActivityStrategy extends AbstractActivityGoodsCalculatePriceStrategy implements ActivityGoodsCalculatePriceStrategy {


    @Autowired
    private DiscountActivityGoodsMapper discountActivityGoodsMapper;

    private static final ActivityType activityType = ActivityType.DISCOUNT;
    @Override
    public CalculatePriceResponse calculatePrice(CalculatePriceRequest calculatePriceRequest) {

        try {
            CalculatePriceRequest calculatePriceRequest1 = calculatePriceRequest;
            Long goodsBaseId = calculatePriceRequest1.getGoodsBaseId();
            Integer quantity = calculatePriceRequest1.getQuantity();
            BigDecimal originalPrice = calculatePriceRequest1.getOriginalPrice();
            List<DiscountActivityGoodsInfo> discountActivityGoodsInfoList = discountActivityGoodsMapper.getByGoodsBaseId(goodsBaseId, quantity, new Date());
            if (CollectionUtils.isEmpty(discountActivityGoodsInfoList)) {
                return super.calculatePrice(calculatePriceRequest);
            }
            //取第一条最接近quantity的数据
            DiscountActivityGoodsInfo discountActivityGoodsInfo = discountActivityGoodsInfoList.get(0);
            CalculatePriceResponse calculatePriceResponse = getCalculatePriceResponse(discountActivityGoodsInfo, originalPrice, quantity);

            log.info("DiscountActivityStrategy calculatePrice Result ：{}", JSONObject.toJSONString(calculatePriceResponse));
            return calculatePriceResponse;
        } catch (Exception e) {
            //如果满折活动出现错误 使用默认的计算价格策略
            log.error("DiscountActivityStrategy calculatePrice Error : {}", ExceptionUtils.getStackTrace(e));
            return super.calculatePrice(calculatePriceRequest);
        }

    }

    @Override
    public ActivityType getActivityType() {
        return activityType;
    }

    /**
     * 组装活动数据
     *
     * @param discountActivityGoodsInfo
     * @param originalPrice
     * @param quantity
     * @return
     */
    private CalculatePriceResponse getCalculatePriceResponse(DiscountActivityGoodsInfo discountActivityGoodsInfo, BigDecimal originalPrice, Integer quantity) {
        //获取折扣 如7.00折 要将小数点左移1位
        //Integer conditionAmount = discountActivityGoodsInfo.getConditionAmount();
        BigDecimal discount = discountActivityGoodsInfo.getDiscount().movePointLeft(1);

        //参加活动的商品原总价：(商品原价* 数量)
        BigDecimal originalTotalPrice = originalPrice.multiply(BigDecimal.valueOf(quantity));

        CalculatePriceResponse calculatePriceResponse = new CalculatePriceResponse();
        //参与活动的商品总价: (商品原价 * 商品数量 * 折扣) 四舍五入保留两位小数
        BigDecimal activityPrice = originalPrice.multiply(BigDecimal.valueOf(quantity)).multiply(discount).setScale(2, RoundingMode.HALF_UP);
        calculatePriceResponse.setActivityPrice(activityPrice);
        //参与活动的商品数量
        calculatePriceResponse.setActivityQuantity(quantity);
        //未参加活动的商品数量
        calculatePriceResponse.setNotJoinActivityQuantity(0);
        calculatePriceResponse.setActivityType(activityType.getCode());
        //差价 （参加活动的商品原总价 - 参与活动的商品总价）
        calculatePriceResponse.setPriceDifference(originalTotalPrice.subtract(activityPrice));
        //参加活动后每个商品的单价
        calculatePriceResponse.setActivityGoodsPrice(originalPrice.multiply(discount));

        calculatePriceResponse.setActivityId(discountActivityGoodsInfo.getActivityId());

        return calculatePriceResponse;
    }
}
```
封装请求及响应数据结构，实现了不同计算价格到策略后

接下来就使用ActivityCalculatePriceProcessor来实现 一件商品如果参加了多个活动

不同的活动有不同价格算法策略，到底应该返回哪一种策略（参加什么活动）的逻辑

在购物车和提交订单时 后端接收到前端数据后 只需要将商品相关信息封装到CalculatePriceRequest后

调用ActivityCalculatePriceProcessor.calculatePrice方法即可获取最低价

目前添可电器商城只有满折活动 如果后续有其他活动 要比较一个商品参与不同活动的最低价格

新的活动计算价格逻辑代码 只需要继承AbstractActivityGoodsCalculatePriceStrategy类 重写calculatePrice方法即可

比较价格的逻辑由ActivityCalculatePriceProcessor处理


```java
/**
 * 活动商品计算价格
 */
@Slf4j
@Service
public class ActivityCalculatePriceProcessor implements InitializingBean {

    /**
     * 目前所有策略封装在list中
     * 后续扩展多个策略（活动）时，可以将list改为map key为活动类型 value为ActivityGoodsCalculatePriceStrategy具体策略
     */
    private List<ActivityGoodsCalculatePriceStrategy> strategies;

    @Autowired
    private ApplicationContext applicationContext;

    public ActivityCalculatePriceProcessor() {
        this.strategies = new ArrayList<>();
    }

    public void addStrategy(ActivityGoodsCalculatePriceStrategy strategy) {
        this.strategies.add(strategy);
    }

    /**
     * 获取所有的计算价格的策略
     * @throws Exception
     */
    @Override
    public void afterPropertiesSet() throws Exception {
        Map<String, ActivityGoodsCalculatePriceStrategy> beansOfType = applicationContext.getBeansOfType(ActivityGoodsCalculatePriceStrategy.class);
        for (ActivityGoodsCalculatePriceStrategy activityGoodsCalculatePriceStrategy : beansOfType.values()) {
            addStrategy(activityGoodsCalculatePriceStrategy);
        }
    }

    /**
     * 计算最低价格
     * @param calculatePriceRequest 商品原价及数量等信息
     * @return CalculatePriceResponse
     */
    public CalculatePriceResponse calculatePrice(CalculatePriceRequest calculatePriceRequest) {
        CalculatePriceResponse calculatePriceResponse = new CalculatePriceResponse();
        BigDecimal minPrice = BigDecimal.valueOf(Long.MAX_VALUE);
        for (ActivityGoodsCalculatePriceStrategy strategy : strategies) {
            CalculatePriceResponse calculatePriceResponseByStrategy= strategy.calculatePrice(calculatePriceRequest);
            if (calculatePriceResponseByStrategy.getActivityPrice().compareTo(minPrice) < 0) {
                minPrice = calculatePriceResponseByStrategy.getActivityPrice();
                calculatePriceResponse.setActivityPrice(minPrice);
                calculatePriceResponse.setActivityQuantity(calculatePriceResponseByStrategy.getActivityQuantity());
                calculatePriceResponse.setNotJoinActivityQuantity(calculatePriceResponseByStrategy.getNotJoinActivityQuantity());
                calculatePriceResponse.setActivityType(calculatePriceResponseByStrategy.getActivityType());
                calculatePriceResponse.setPriceDifference(calculatePriceResponseByStrategy.getPriceDifference());
                calculatePriceResponse.setActivityDesc(calculatePriceResponseByStrategy.getActivityDesc());
                calculatePriceResponse.setActivityId(calculatePriceResponseByStrategy.getActivityId());
                calculatePriceResponse.setActivityGoodsPrice(calculatePriceResponseByStrategy.getActivityGoodsPrice());
            }
        }
        log.info("calculatePrice Result ：{}", JSONObject.toJSONString(calculatePriceResponse));
        return calculatePriceResponse;
    }
}

```

calculatePrice方法是for循环比较不同策略的价格 返回一个最低价 这种循环的方法在策略较少时可以使用

后续策略太多的话 for循环串行计算价格的性能 就不如并行计算价格返回一起处理的性能好

例如JUC工具包中的CountDownLatch和CyclicBarrier

使用策略模式实现计算价格并比较的功能 多数情况下新增商品活动 计算活动价 只需要新加一个Strategy即可

比较价格的逻辑由Processor处理 计算价格和比较价格的逻辑分开隔离 尽量减少代码耦合

观察者模式
---
##### 应用场景

Spring Event是Spring框架中的一个事件机制，用于实现事件的发布和监听，可以用于实现以下功能：

业务解耦：通过事件机制，可以将业务逻辑解耦，将事件的发布和监听分离，提高代码的可维护性和可扩展性。

事件驱动编程：通过事件机制，可以实现事件驱动编程，将事件作为驱动器，根据事件的发生来触发相应的业务逻辑，提高代码的响应速度和性能。

业务扩展：通过事件机制，可以实现业务的扩展，当业务逻辑发生变化时，只需要新增或修改相应的事件监听器，而不需要修改原有的业务逻辑，提高代码的可维护性和可扩展性。

事务管理：通过事件机制，可以实现事务的管理，当事件发生异常时，可以通过事件机制来实现事务的回滚和异常处理，提高代码的可靠性和稳定性。

监控和统计：通过事件机制，可以实现业务的监控和统计，当事件发生时，可以通过事件机制来触发相应的监控和统计逻辑，提高代码的可观测性和可维护性。

总之，Spring Event是一个非常有用的事件机制，可以用于实现业务解耦、事件驱动编程、业务扩展、事务管理、监控和统计等功能，提高代码的可维护性、可扩展性、可靠性、可观测性和性能

##### 具体实现

对接CRM系统的会员中心 用户在商城的下单或者评价商品等动作 触发会员任务后 

使用SpringEvent+自定义线程池 实现事件监听 并异步通知CRM系统

AsyncEventConfig定义一个线程池来异步处理监听到的事件

```java
@EnableAsync
@Configuration
public class AsyncEventConfig {

    @Bean(name = "asyncEventExecutor")
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(5);
        executor.setThreadNamePrefix("AsyncEventExecutor-");
        executor.initialize();
        return executor;
    }
}
```

AbstractEventHandler作为抽象类定义了处理事件的方法 

在方法上加上注解@EventListener实现事件监听，以及注解@Async("asyncEventExecutor")实现异步处理事件

```java
@Slf4j
public class AbstractEventHandler<T extends ApplicationEvent> {

    @Autowired
    public TkService tkService;

    @EventListener
    @Async("asyncEventExecutor")
    public void handleEvent(T event) {
        log.debug("handleMyEvent:{}", event);
    }
}
```

以会员中心的会员任务-用户下单后 评价配件商品为例

我们定义了一个EvaluateAccessoryEvent的事件 继承ApplicationEvent 封装请求参数

```java
/**
 * 商品评价（配件or小件）事件
 */
@Getter
@Setter
public class EvaluateAccessoryEvent extends ApplicationEvent {

    /**
     * 用户token
     */
    private String token;

    /**
     * 订单ID
     */
    private String orderId;

    /**
     * 商品ID
     */
    private Integer goodsId;

    /**
     * 订单商品实付金额
     */
    private BigDecimal orderGoodsPaymentAmount;


    public EvaluateAccessoryEvent(Object source) {
        super(source);
    }

}
```

前端调用后端评价商品接口后 后端评价商品接口在返回success前调用了CrmEventService的sendEvaluateAccessoryEvent方法

方法内applicationEventPublisher将EvaluateAccessoryEvent事件进行发送

```java
@Slf4j
@Service
public class CrmEventService {

    @Autowired
    private ApplicationEventPublisher applicationEventPublisher;

    @Autowired
    private ReturnMoneyDao returnMoneyDao;

    @Autowired
    private OrderBaseDao orderBaseDao;

    @Autowired
    private TkService tkService;
    
    /**
     * 评价配件商品后发送消息给CRM
     *
     * @param token
     */
    public void sendEvaluateAccessoryEvent(String token, String orderId, Integer goodsBaseId, BigDecimal orderGoodsPaymentAmount) {
        EvaluateAccessoryEvent evaluateAccessoryEvent = new EvaluateAccessoryEvent(this);
        evaluateAccessoryEvent.setToken(token);
        evaluateAccessoryEvent.setGoodsId(goodsBaseId);
        evaluateAccessoryEvent.setOrderId(orderId);
        evaluateAccessoryEvent.setOrderGoodsPaymentAmount(orderGoodsPaymentAmount);
        applicationEventPublisher.publishEvent(evaluateAccessoryEvent);
    }
        
}    
```

我们实现一个EvaluateAccessoryEventHandler的事件处理器 继承了AbstractEventHandler

在泛型上指定EvaluateAccessoryEvent 重写了handleEvent方法 指定入参EvaluateAccessoryEvent

即可监听EvaluateAccessoryEvent事件并异步处理通知CRM

```java
/**
 * 商品评价（配件or小件）事件处理
 */
@Component
@Slf4j
public class EvaluateAccessoryEventHandler extends AbstractEventHandler<EvaluateAccessoryEvent> {

    @Override
    public void handleEvent(EvaluateAccessoryEvent event) {
        String token = event.getToken();
        String userCenterUserId = tkService.getUserCenterUserId(token);
        if (StringUtils.isBlank(userCenterUserId)) {
            log.error("EvaluateAccessoryEventHandler Failure, userCenterUserId Don't Exist, token :{}", token);
            return;
        }

        MemberTaskDTO memberTaskDTO = new MemberTaskDTO();
        memberTaskDTO.setUserId(userCenterUserId);
        memberTaskDTO.setOrderId(event.getOrderId());
        memberTaskDTO.setChangeType(CRMChangeType.ADD.code());
        memberTaskDTO.setTaskType(MemberTaskTypeEnum.EVALUATE_ACCESSORY.code());
        tkService.sendMsgToCRM(memberTaskDTO);
    }

}
```

使用Spring Event + 自定义线程池

将添可电器商城评价商品 和 CRM会员中心-用户任务-评价商品两个的业务功能进行解耦和代码分离

在不影响添可电器商城评价商品的接口响应速度的前提下 提高了评价商品功能的可维护性和可扩展性


状态模式
---

##### 应用场景


##### 具体实现

原型模式
---

##### 应用场景


##### 具体实现

责任链模式
---

##### 应用场景


##### 具体实现


