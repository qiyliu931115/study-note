开宗明义
---

在实际生产环境中，一些业务场景我们可以借助一些设计模式来实现我们的需要的功能。

本篇中，具体介绍了双重检查锁单例模式，策略模式，观察者模式，状态模式，原型模式，责任链模式六个设计模式的应用场景和实际需求中的应用。


双重检查锁单例模式
---
##### 应用场景

双重检查单例模式是一种线程安全的单例模式实现方式，可以在实际生产中应用于需要保证全局唯一性的场景，例如：

数据库连接池：在一个应用中，可能需要多个线程同时访问数据库，为了避免每次访问数据库都需要创建新的连接，可以使用单例模式来创建数据库连接池，保证全局唯一性，提高数据库访问的效率。

日志记录器：在一个应用中，可能需要多个线程同时记录日志，为了避免日志记录器的实例被多个线程创建，可以使用单例模式来创建日志记录器，保证全局唯一性，避免日志记录的重复和混乱。

配置文件管理器：在一个应用中，可能需要多个线程同时访问配置文件，为了避免每次访问配置文件都需要创建新的实例，可以使用单例模式来创建配置文件管理器，保证全局唯一性，提高配置文件访问的效率。

需要注意的是，双重检查单例模式虽然可以保证线程安全，但是在一些特殊的场景下可能会出现问题，例如在多线程环境下，如果一个线程正在创建实例，而另一个线程同时访问了getInstance方法，可能会导致实例被创建多次。因此，在使用双重检查单例模式时，需要仔细考虑线程安全性和性能问题，确保能够满足实际需求。

##### 具体实现

在高可用架构中，为了在系统发生故障时能限定传播范围和影响范围，不会出现滚雪球效应。我们一般采用隔离的方式。

具体如：线程隔离，进程隔离，读写隔离，集群隔离，机房隔离，冷热隔离，动静隔离，爬虫隔离等。

在线程隔离中，很多情况下我们需要一个线程池来对一个接口和其他接口做线程隔离，在该接口的方法内会使用单独的线程池来处理业务逻辑，来实现线程隔离的效果。

在这里就具体说明下使用双重检查单例创建一个线程池及注意事项。

```java
public class DoubleCheckSingleton {

    private static volatile ThreadPoolTaskExecutor threadPoolTaskExecutor = null;

    public DoubleCheckSingleton () {
        System.out.println(Thread.currentThread().getName() + ":DoubleCheckSingleton");
    }

    public static ThreadPoolTaskExecutor getInstance() {
        if (threadPoolTaskExecutor == null) {
            synchronized (DoubleCheckSingleton.class) {
                if (threadPoolTaskExecutor == null) {
                    ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
                    threadPoolTaskExecutor.setCorePoolSize(5);
                    threadPoolTaskExecutor.setMaxPoolSize(5);
                    threadPoolTaskExecutor.setThreadNamePrefix("AsyncEventExecutor-");
                    threadPoolTaskExecutor.initialize();
                    return threadPoolTaskExecutor;
                }
            }
        }
        return threadPoolTaskExecutor;
    }

    public static void main(String[] args) {
        ThreadPoolTaskExecutor instance = getInstance();
        instance.execute(new Runnable() {
            @Override
            public void run() {
                // 执行任务
            }
        });
    }
}

```
Class锁

双重检查锁单例模式中，使用锁来保证线程安全，锁的对象是Singleton.class，而不是this对象，是因为this对象在多线程环境下是不安全的。

在单例模式中，单例对象是在类加载的时候就被创建出来的，因此锁的对象应该是类对象，而不是实例对象。

使用Singleton.class作为锁对象，可以保证在多线程环境下，只有一个线程可以进入同步代码块，创建单例对象。

而使用this对象作为锁对象，会出现多个实例的情况，因为在多线程环境下，每个线程都有自己的实例对象，锁的是自己的实例对象，无法保证只有一个线程可以进入同步代码块。

另外，使用Singleton.class作为锁对象，可以保证在类加载的时候就被初始化，避免了在多线程环境下出现多个实例的情况。

而使用this对象作为锁对象，需要在实例化之后才能使用，无法保证在实例化之前不会出现多个实例的情况。

volatile关键字

双重检查锁单例模式中，使用volatile关键字来修饰单例对象的变量，是为了保证多线程环境下的可见性和有序性。

在双重检查锁单例模式中，第一次检查单例对象是否为null时，如果多个线程同时进入了这个判断语句，

那么它们都会认为单例对象为null，然后会进入同步代码块中，创建单例对象。

但是，如果没有使用volatile关键字来修饰单例对象的变量，那么在某个线程创建单例对象之后，其他线程可能无法立即看到这个变化，仍然会认为单例对象为null，

然后继续创建单例对象，这样就会创建多个实例，违背了单例模式的初衷。

使用volatile关键字来修饰单例对象的变量，可以保证在多线程环境下，单例对象的变化对其他线程是可见的，从而避免了创建多个实例的问题。

同时，volatile关键字还可以保证单例对象的创建是有序的，避免了指令重排的问题。


策略模式
---

##### 应用场景

策略模式是一种行为型设计模式，它定义了一系列算法，将每个算法都封装起来，并且使它们之间可以互换。策略模式可以让算法的变化独立于使用算法的客户端，从而实现了算法的动态切换和扩展。策略模式适用于以下场景：

多个类只有算法或行为上的不同，可以使用策略模式封装这些不同的算法或行为，使得它们可以互换，从而实现动态切换和扩展。

需要在运行时动态地选择算法或行为的场景，可以使用策略模式来实现。

需要封装一些复杂的算法或行为，使得客户端可以简化使用，可以使用策略模式来实现。

需要在不同的上下文中使用不同的算法或行为，可以使用策略模式来实现。

需要在算法或行为的实现上保持一定的独立性，可以使用策略模式来实现。

总之，策略模式适用于需要封装一系列算法或行为，并且需要动态切换和扩展这些算法或行为的场景。它可以使得算法或行为的变化独立于使用算法或行为的客户端，从而提高代码的可维护性、可扩展性和可重用性。

##### 具体实现

添可电器商品功能：在购物车及提交订单时计算商品是否参加活动及最低价格

首先定义了一个计算商品价格到策略接口，这个接口定义了计算价格到方法和返回值，以及不同策略所属到活动类型

```java
/**
 * 活动商品计算价格
 */
public interface ActivityGoodsCalculatePriceStrategy {

    /**
     * 根据活动来计算商品价格
     * @param calculatePriceRequest 商品原价及数量等信息
     * @return CalculatePriceResponse
     */
    CalculatePriceResponse calculatePrice(CalculatePriceRequest calculatePriceRequest);

    /**
     * 获取活动类型
     * @return ActivityType
     */
    ActivityType getActivityType();
}
```

ActivityType作为枚举，定义不同到活动到类型枚举和活动名称 用于后端逻辑判断和返回前端使用

```java
public enum ActivityType {

    NORMAL(0,"不参加活动"),
    DISCOUNT(1,"满折活动"),

    ;
    private final Integer code;
    private final String message;

    ActivityType(Integer code, String message) {
        this.code = code;
        this.message = message;
    }

    public Integer getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }

    public static String getMessageByCode(Integer code) {
        if (null == code) {
            return null;
        }
        for (ActivityType value : values()) {
            if (value.getCode().equals(code)) {
                return value.message;
            }
        }
        return null;
    }

    public static ActivityType getByCode(Integer code) {
        if (null == code) {
            return null;
        }
        for (ActivityType value : values()) {
            if (value.getCode().equals(code)) {
                return value;
            }
        }
        return null;
    }
}
```
CalculatePriceRequest作为请求数据 包含了商品id，商品正常价格，商品数量（购物车和提交订单页面的商品数量）等数据

```java
/**
 * 计算商品价格请求数据
 */
@Data
public class CalculatePriceRequest {

    @ApiModelProperty("goods_common表id(SPU)")
    @NotNull
    private Long goodsCommonId;

    @ApiModelProperty("goods_base表id(SKU)")
    @NotNull
    private Long goodsBaseId;

    @ApiModelProperty("商品原价（正常价格）")
    @NotNull
    private BigDecimal originalPrice;

    @ApiModelProperty("商品数量")
    @NotNull
    private Integer quantity;

    /**
     * 活动类型 1-满折活动
     *
     * @see ActivityType
     */
    @ApiModelProperty("指定活动类型，如传入1代表只按满折活动来计算活动总价，即使商品参加其他活动且活动总价比满折活动低，依然按满折活动计算")
    @NotNull
    private Integer activityType;
}
```

CalculatePriceResponse封装了计算价格到结果，封装了是否参与活动 活动id 活动类型 活动说明 活动价

以及同一个商品有多件 有几件可以参与活动 有多少件不能参加活动 （例如限购活动中，只能有一件按活动价 其余按原价 按原价到商品可以使用优惠券）

```java
/**
 * 商品计算价格结果
 */
@Data
public class CalculatePriceResponse {

    @ApiModelProperty("活动ID")
    private Long activityId;

    @ApiModelProperty("参与活动的商品总价: 如满折活动：商品原价 * 参加活动的商品数量 * 折扣")
    private BigDecimal activityPrice;

    @ApiModelProperty("参与活动的商品单价: 如满折活动：商品原价 * 折扣。没有参加任何活动这里就是原价")
    private BigDecimal activityGoodsPrice;

    @ApiModelProperty("参与活动的商品数量")
    private Integer activityQuantity;

    @ApiModelProperty("未参与活动的商品数量")
    private Integer notJoinActivityQuantity;

    @ApiModelProperty("差价（参加活动的商品原总价 - 参与活动的商品总价）")
    private BigDecimal priceDifference;

    /**
     * 活动类型 1-满折活动
     *
     * @see ActivityType
     */
    @ApiModelProperty("活动类型 0-不参加活动，1-满折活动")
    private Integer activityType;

    @ApiModelProperty("活动详情描述,如：该商品满两件8折，三件5折")
    private String activityDesc;
}
```


AbstractActivityGoodsCalculatePriceStrategy实现了ActivityGoodsCalculatePriceStrategy接口，作为默认到计算商品价格的策略 

如果商品不参加任何活动，计算价格到逻辑就由AbstractActivityGoodsCalculatePriceStrategy处理

```java
/**
 * 不参与任何活动商品的计算价格策略
 */
@Slf4j
@Service
public class AbstractActivityGoodsCalculatePriceStrategy implements ActivityGoodsCalculatePriceStrategy {


    private static final ActivityType activityType = ActivityType.NORMAL;
    /**
     * 该商品任何活动都没参加
     *
     * @param calculatePriceRequest
     * @return
     */
    @Override
    public CalculatePriceResponse calculatePrice(CalculatePriceRequest calculatePriceRequest) {
        BigDecimal originalPrice = calculatePriceRequest.getOriginalPrice();
        Integer quantity = calculatePriceRequest.getQuantity();
        CalculatePriceResponse calculatePriceResponse = new CalculatePriceResponse();
        BigDecimal originalTotalPrice = originalPrice.multiply(BigDecimal.valueOf(quantity));
        calculatePriceResponse.setActivityPrice(originalTotalPrice);
        calculatePriceResponse.setActivityQuantity(0);
        calculatePriceResponse.setNotJoinActivityQuantity(quantity);
        calculatePriceResponse.setActivityType(activityType.getCode());
        //差价 （商品总价 - 参与活动的商品总价） 无活动参加 差价是0
        calculatePriceResponse.setPriceDifference(BigDecimal.ZERO);
        //参加活动后每个商品的单价 这里没有参加任何活动就是原价
        calculatePriceResponse.setActivityGoodsPrice(originalPrice);
        //不参加任何活动 设置为0
        calculatePriceResponse.setActivityId(0L);
        log.info("AbstractActivityGoodsCalculatePriceStrategy calculatePrice Result ：{}", JSONObject.toJSONString(calculatePriceResponse));
        return calculatePriceResponse;
    }

    @Override
    public ActivityType getActivityType() {
        return activityType;
    }
}

```

DiscountActivityStrategy继承了AbstractActivityGoodsCalculatePriceStrategy

如果如果商品参与了满折活动就由DiscountActivityStrategy处理，如果满折活动计算价格发生异常 就由AbstractActivityGoodsCalculatePriceStrategy处理

```java
/**
 * 参与满折活动商品的计算价格策略
 */
@Slf4j
@Service
public class DiscountActivityStrategy extends AbstractActivityGoodsCalculatePriceStrategy implements ActivityGoodsCalculatePriceStrategy {


    @Autowired
    private DiscountActivityGoodsMapper discountActivityGoodsMapper;

    private static final ActivityType activityType = ActivityType.DISCOUNT;
    @Override
    public CalculatePriceResponse calculatePrice(CalculatePriceRequest calculatePriceRequest) {

        try {
            CalculatePriceRequest calculatePriceRequest1 = calculatePriceRequest;
            Long goodsBaseId = calculatePriceRequest1.getGoodsBaseId();
            Integer quantity = calculatePriceRequest1.getQuantity();
            BigDecimal originalPrice = calculatePriceRequest1.getOriginalPrice();
            List<DiscountActivityGoodsInfo> discountActivityGoodsInfoList = discountActivityGoodsMapper.getByGoodsBaseId(goodsBaseId, quantity, new Date());
            if (CollectionUtils.isEmpty(discountActivityGoodsInfoList)) {
                return super.calculatePrice(calculatePriceRequest);
            }
            //取第一条最接近quantity的数据
            DiscountActivityGoodsInfo discountActivityGoodsInfo = discountActivityGoodsInfoList.get(0);
            CalculatePriceResponse calculatePriceResponse = getCalculatePriceResponse(discountActivityGoodsInfo, originalPrice, quantity);

            log.info("DiscountActivityStrategy calculatePrice Result ：{}", JSONObject.toJSONString(calculatePriceResponse));
            return calculatePriceResponse;
        } catch (Exception e) {
            //如果满折活动出现错误 使用默认的计算价格策略
            log.error("DiscountActivityStrategy calculatePrice Error : {}", ExceptionUtils.getStackTrace(e));
            return super.calculatePrice(calculatePriceRequest);
        }

    }

    @Override
    public ActivityType getActivityType() {
        return activityType;
    }

    /**
     * 组装活动数据
     *
     * @param discountActivityGoodsInfo
     * @param originalPrice
     * @param quantity
     * @return
     */
    private CalculatePriceResponse getCalculatePriceResponse(DiscountActivityGoodsInfo discountActivityGoodsInfo, BigDecimal originalPrice, Integer quantity) {
        //获取折扣 如7.00折 要将小数点左移1位
        //Integer conditionAmount = discountActivityGoodsInfo.getConditionAmount();
        BigDecimal discount = discountActivityGoodsInfo.getDiscount().movePointLeft(1);

        //参加活动的商品原总价：(商品原价* 数量)
        BigDecimal originalTotalPrice = originalPrice.multiply(BigDecimal.valueOf(quantity));

        CalculatePriceResponse calculatePriceResponse = new CalculatePriceResponse();
        //参与活动的商品总价: (商品原价 * 商品数量 * 折扣) 四舍五入保留两位小数
        BigDecimal activityPrice = originalPrice.multiply(BigDecimal.valueOf(quantity)).multiply(discount).setScale(2, RoundingMode.HALF_UP);
        calculatePriceResponse.setActivityPrice(activityPrice);
        //参与活动的商品数量
        calculatePriceResponse.setActivityQuantity(quantity);
        //未参加活动的商品数量
        calculatePriceResponse.setNotJoinActivityQuantity(0);
        calculatePriceResponse.setActivityType(activityType.getCode());
        //差价 （参加活动的商品原总价 - 参与活动的商品总价）
        calculatePriceResponse.setPriceDifference(originalTotalPrice.subtract(activityPrice));
        //参加活动后每个商品的单价
        calculatePriceResponse.setActivityGoodsPrice(originalPrice.multiply(discount));

        calculatePriceResponse.setActivityId(discountActivityGoodsInfo.getActivityId());

        return calculatePriceResponse;
    }
}
```
封装请求及响应数据结构，实现了不同计算价格到策略后

接下来就使用ActivityCalculatePriceProcessor来实现 一件商品如果参加了多个活动

不同的活动有不同价格算法策略，到底应该返回哪一种策略（参加什么活动）的逻辑

在购物车和提交订单时 后端接收到前端数据后 只需要将商品相关信息封装到CalculatePriceRequest后

调用ActivityCalculatePriceProcessor.calculatePrice方法即可获取最低价

目前添可电器商城只有满折活动 如果后续有其他活动 要比较一个商品参与不同活动的最低价格

新的活动计算价格逻辑代码 只需要继承AbstractActivityGoodsCalculatePriceStrategy类 重写calculatePrice方法即可

比较价格的逻辑由ActivityCalculatePriceProcessor处理


```java
/**
 * 活动商品计算价格
 */
@Slf4j
@Service
public class ActivityCalculatePriceProcessor implements InitializingBean {

    /**
     * 目前所有策略封装在list中
     * 后续扩展多个策略（活动）时，可以将list改为map key为活动类型 value为ActivityGoodsCalculatePriceStrategy具体策略
     */
    private List<ActivityGoodsCalculatePriceStrategy> strategies;

    @Autowired
    private ApplicationContext applicationContext;

    public ActivityCalculatePriceProcessor() {
        this.strategies = new ArrayList<>();
    }

    public void addStrategy(ActivityGoodsCalculatePriceStrategy strategy) {
        this.strategies.add(strategy);
    }

    /**
     * 获取所有的计算价格的策略
     * @throws Exception
     */
    @Override
    public void afterPropertiesSet() throws Exception {
        Map<String, ActivityGoodsCalculatePriceStrategy> beansOfType = applicationContext.getBeansOfType(ActivityGoodsCalculatePriceStrategy.class);
        for (ActivityGoodsCalculatePriceStrategy activityGoodsCalculatePriceStrategy : beansOfType.values()) {
            addStrategy(activityGoodsCalculatePriceStrategy);
        }
    }

    /**
     * 计算最低价格
     * @param calculatePriceRequest 商品原价及数量等信息
     * @return CalculatePriceResponse
     */
    public CalculatePriceResponse calculatePrice(CalculatePriceRequest calculatePriceRequest) {
        CalculatePriceResponse calculatePriceResponse = new CalculatePriceResponse();
        BigDecimal minPrice = BigDecimal.valueOf(Long.MAX_VALUE);
        for (ActivityGoodsCalculatePriceStrategy strategy : strategies) {
            CalculatePriceResponse calculatePriceResponseByStrategy= strategy.calculatePrice(calculatePriceRequest);
            if (calculatePriceResponseByStrategy.getActivityPrice().compareTo(minPrice) < 0) {
                minPrice = calculatePriceResponseByStrategy.getActivityPrice();
                calculatePriceResponse.setActivityPrice(minPrice);
                calculatePriceResponse.setActivityQuantity(calculatePriceResponseByStrategy.getActivityQuantity());
                calculatePriceResponse.setNotJoinActivityQuantity(calculatePriceResponseByStrategy.getNotJoinActivityQuantity());
                calculatePriceResponse.setActivityType(calculatePriceResponseByStrategy.getActivityType());
                calculatePriceResponse.setPriceDifference(calculatePriceResponseByStrategy.getPriceDifference());
                calculatePriceResponse.setActivityDesc(calculatePriceResponseByStrategy.getActivityDesc());
                calculatePriceResponse.setActivityId(calculatePriceResponseByStrategy.getActivityId());
                calculatePriceResponse.setActivityGoodsPrice(calculatePriceResponseByStrategy.getActivityGoodsPrice());
            }
        }
        log.info("calculatePrice Result ：{}", JSONObject.toJSONString(calculatePriceResponse));
        return calculatePriceResponse;
    }
}

```

calculatePrice方法是for循环比较不同策略的价格 返回一个最低价 这种循环的方法在策略较少时可以使用

后续策略太多的话 for循环串行计算价格的性能 就不如并行计算价格返回一起处理的性能好

例如JUC工具包中的CountDownLatch和CyclicBarrier

使用策略模式实现计算价格并比较的功能 多数情况下新增商品活动 计算活动价 只需要新加一个Strategy即可

比较价格的逻辑由Processor处理 计算价格和比较价格的逻辑分开隔离 尽量减少代码耦合

观察者模式
---
##### 应用场景

Spring Event是Spring框架中的一个事件机制，用于实现事件的发布和监听，可以用于实现以下功能：

业务解耦：通过事件机制，可以将业务逻辑解耦，将事件的发布和监听分离，提高代码的可维护性和可扩展性。

事件驱动编程：通过事件机制，可以实现事件驱动编程，将事件作为驱动器，根据事件的发生来触发相应的业务逻辑，提高代码的响应速度和性能。

业务扩展：通过事件机制，可以实现业务的扩展，当业务逻辑发生变化时，只需要新增或修改相应的事件监听器，而不需要修改原有的业务逻辑，提高代码的可维护性和可扩展性。

事务管理：通过事件机制，可以实现事务的管理，当事件发生异常时，可以通过事件机制来实现事务的回滚和异常处理，提高代码的可靠性和稳定性。

监控和统计：通过事件机制，可以实现业务的监控和统计，当事件发生时，可以通过事件机制来触发相应的监控和统计逻辑，提高代码的可观测性和可维护性。

总之，Spring Event是一个非常有用的事件机制，可以用于实现业务解耦、事件驱动编程、业务扩展、事务管理、监控和统计等功能，提高代码的可维护性、可扩展性、可靠性、可观测性和性能

##### 具体实现

对接CRM系统的会员中心 用户在商城的下单或者评价商品等动作 触发会员任务后 

使用SpringEvent+自定义线程池 实现事件监听 并异步通知CRM系统

AsyncEventConfig定义一个线程池来异步处理监听到的事件

```java
@EnableAsync
@Configuration
public class AsyncEventConfig {

    @Bean(name = "asyncEventExecutor")
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(5);
        executor.setThreadNamePrefix("AsyncEventExecutor-");
        executor.initialize();
        return executor;
    }
}
```

AbstractEventHandler作为抽象类定义了处理事件的方法 

在方法上加上注解@EventListener实现事件监听，以及注解@Async("asyncEventExecutor")实现异步处理事件

```java
@Slf4j
public class AbstractEventHandler<T extends ApplicationEvent> {

    @Autowired
    public TkService tkService;

    @EventListener
    @Async("asyncEventExecutor")
    public void handleEvent(T event) {
        log.debug("handleMyEvent:{}", event);
    }
}
```

以会员中心的会员任务-用户下单后 评价配件商品为例

我们定义了一个EvaluateAccessoryEvent的事件 继承ApplicationEvent 封装请求参数

```java
/**
 * 商品评价（配件or小件）事件
 */
@Getter
@Setter
public class EvaluateAccessoryEvent extends ApplicationEvent {

    /**
     * 用户token
     */
    private String token;

    /**
     * 订单ID
     */
    private String orderId;

    /**
     * 商品ID
     */
    private Integer goodsId;

    /**
     * 订单商品实付金额
     */
    private BigDecimal orderGoodsPaymentAmount;


    public EvaluateAccessoryEvent(Object source) {
        super(source);
    }

}
```

前端调用后端评价商品接口后 后端评价商品接口在返回success前调用了CrmEventService的sendEvaluateAccessoryEvent方法

方法内applicationEventPublisher将EvaluateAccessoryEvent事件进行发送

```java
@Slf4j
@Service
public class CrmEventService {

    @Autowired
    private ApplicationEventPublisher applicationEventPublisher;

    @Autowired
    private ReturnMoneyDao returnMoneyDao;

    @Autowired
    private OrderBaseDao orderBaseDao;

    @Autowired
    private TkService tkService;
    
    /**
     * 评价配件商品后发送消息给CRM
     *
     * @param token
     */
    public void sendEvaluateAccessoryEvent(String token, String orderId, Integer goodsBaseId, BigDecimal orderGoodsPaymentAmount) {
        EvaluateAccessoryEvent evaluateAccessoryEvent = new EvaluateAccessoryEvent(this);
        evaluateAccessoryEvent.setToken(token);
        evaluateAccessoryEvent.setGoodsId(goodsBaseId);
        evaluateAccessoryEvent.setOrderId(orderId);
        evaluateAccessoryEvent.setOrderGoodsPaymentAmount(orderGoodsPaymentAmount);
        applicationEventPublisher.publishEvent(evaluateAccessoryEvent);
    }
        
}    
```

我们实现一个EvaluateAccessoryEventHandler的事件处理器 继承了AbstractEventHandler

在泛型上指定EvaluateAccessoryEvent 重写了handleEvent方法 指定入参EvaluateAccessoryEvent

即可监听EvaluateAccessoryEvent事件并异步处理通知CRM

```java
/**
 * 商品评价（配件or小件）事件处理
 */
@Component
@Slf4j
public class EvaluateAccessoryEventHandler extends AbstractEventHandler<EvaluateAccessoryEvent> {

    @Override
    public void handleEvent(EvaluateAccessoryEvent event) {
        String token = event.getToken();
        String userCenterUserId = tkService.getUserCenterUserId(token);
        if (StringUtils.isBlank(userCenterUserId)) {
            log.error("EvaluateAccessoryEventHandler Failure, userCenterUserId Don't Exist, token :{}", token);
            return;
        }

        MemberTaskDTO memberTaskDTO = new MemberTaskDTO();
        memberTaskDTO.setUserId(userCenterUserId);
        memberTaskDTO.setOrderId(event.getOrderId());
        memberTaskDTO.setChangeType(CRMChangeType.ADD.code());
        memberTaskDTO.setTaskType(MemberTaskTypeEnum.EVALUATE_ACCESSORY.code());
        tkService.sendMsgToCRM(memberTaskDTO);
    }

}
```

使用Spring Event + 自定义线程池

将添可电器商城评价商品 和 CRM会员中心-用户任务-评价商品两个的业务功能进行解耦和代码分离

在不影响添可电器商城评价商品的接口响应速度的前提下 提高了评价商品功能的可维护性和可扩展性


状态模式
---

##### 应用场景

状态模式是一种行为型设计模式，它允许对象在内部状态发生改变时改变它的行为，从而使对象看起来像是改变了它的类。状态模式适用于以下场景：

对象的行为取决于它的状态，而且它的状态可能在运行时发生改变，可以使用状态模式来实现。

对象的行为包含大量的条件语句，而且这些条件语句依赖于对象的状态，可以使用状态模式来将这些条件语句转换为状态类。

对象的状态转换比较复杂，而且包含大量的条件语句，可以使用状态模式来将状态转换逻辑封装在状态类中，从而简化代码。

对象的状态转换需要在运行时动态地进行，可以使用状态模式来实现。

对象的状态转换需要在不同的状态下执行不同的行为，可以使用状态模式来实现。

总之，状态模式适用于需要将对象的状态和行为进行分离，并且需要在运行时动态地改变对象的行为的场景。它可以使得对象的状态转换逻辑更加清晰，代码更加简洁，同时也提高了代码的可维护性和可扩展性。

##### 具体实现

使用Spring官方提供的Spring StateMachine 处理订单状态

在pom文件中引入spring-statemachine-core依赖，

spring-statemachine-redis包是对状态机进行持久化，以及解决分布式数据同步问题

```java
        <!-->Spring状态机的依赖包<!-->
        <dependency>
            <groupId>org.springframework.statemachine</groupId>
            <artifactId>spring-statemachine-core</artifactId>
            <version>2.1.3.RELEASE</version>
        </dependency>
        <!-->Spring状态机Redis持久化的依赖包<!-->
        <dependency>
            <groupId>org.springframework.statemachine</groupId>
            <artifactId>spring-statemachine-redis</artifactId>
            <version>1.2.9.RELEASE</version>
        </dependency>
```

OrderState定义订单的状态

```java
/**
 * 订单状态枚举
 */
public enum OrderState {
    /**
     * 待支付
     */
    ORDER_WAIT_PAY,

    /**
     * 待发货
     */
    ORDER_WAIT_SEND,

    /**
     * 待收货
     */
    ORDER_WAIT_RECEIVE,
    /**
     * 订单完成
     */
    ORDER_FINISH,

    ;
}
```

OrderStateChangeAction定义订单流程事件

```java
public enum OrderStateChangeAction {

    /**
     * 支付操作 触发后 待支付-》待发货
     */
    PAY_ORDER,

    /**
     * 发货操作 触发后 待发货-》待收货
     */
    SEND_ORDER,

    /**
     * 收货操作 触发后 待收货-》订单完成
     */
    RECEIVE_ORDER,

    ;
}
```

OrderStateMachineConfig继承StateMachineConfigurerAdapter

重写StateMachineConfigurerAdapter的configure方法 配置状态机的初始状态和状态转化的触发事件

以及Redis的持久化配置

```java
@Configuration
@EnableStateMachine(name = "orderStateMachine")
public class OrderStateMachineConfig extends StateMachineConfigurerAdapter<OrderState, OrderStateChangeAction> {

    @Autowired
    private RedisConnectionFactory redisConnectionFactory;

    @Override
    public void configure(StateMachineStateConfigurer<OrderState, OrderStateChangeAction> states) throws Exception {
        //初始化状态 待支付
        states.withStates().initial(OrderState.ORDER_WAIT_PAY)
                .states(EnumSet.allOf(OrderState.class));
    }

    @Override
    public void configure(StateMachineTransitionConfigurer<OrderState, OrderStateChangeAction> transitions) throws Exception {
        //订单状态转化
        transitions
                .withExternal().source(OrderState.ORDER_WAIT_PAY)
                .target(OrderState.ORDER_WAIT_SEND)
                .event(OrderStateChangeAction.PAY_ORDER) //通过PAY_ORDER事件将待支付改为待发货
                .and()
                .withExternal().source(OrderState.ORDER_WAIT_SEND)
                .target(OrderState.ORDER_WAIT_RECEIVE)
                .event(OrderStateChangeAction.SEND_ORDER)//通过SEND_ORDER事件将待发货改为待收货
                .and()
                .withExternal().source(OrderState.ORDER_WAIT_RECEIVE)
                .target(OrderState.ORDER_FINISH)
                .event(OrderStateChangeAction.RECEIVE_ORDER)//通过ORDER_FINISH事件将待收货改为订单完成
                ;
    }

    /**
     * 状态机redis持久化
     * @return RedisStateMachinePersister
     */
    @Bean
    //@Bean("stateMachineRedisPersister")
    public RedisStateMachinePersister<OrderState, OrderStateChangeAction> getRedisPersister() {
        RedisStateMachineContextRepository<OrderState, OrderStateChangeAction> repository
                = new RedisStateMachineContextRepository<>(redisConnectionFactory);
        RepositoryStateMachinePersist<OrderState, OrderStateChangeAction> persist
                = new RepositoryStateMachinePersist<>(repository);
        return new RedisStateMachinePersister<>(persist);
    }


}
```

OrderStateListener对状态转化时进行监听

```java
@Component
@WithStateMachine(name = "orderStateMachine")
public class OrderStateListener {

    @Autowired
    private RedisTemplate<String, String> stringStringRedisTemplate;

    /**
     * 监听待支付到待发货到事件
     * @param message
     * @return
     */
    @OnTransition(source = "ORDER_WAIT_PAY", target = "ORDER_WAIT_SEND")
    public boolean payToSend (Message<OrderStateChangeAction> message) {
        //获取订单状态， 判断当前订单状态是否为待支付
        Order order = (Order) message.getHeaders().get("order");
        if (order.getOrderState() != OrderState.ORDER_WAIT_PAY) {
            throw new UnsupportedOperationException("Order State Error!");
        }

        //TODO 支付逻辑 微信 支付宝

        // 支付成功后修改 订单状态为待发货 并更新redis缓存
        order.setOrderState(OrderState.ORDER_WAIT_SEND);
        return true;
    }

    @OnTransition(source = "ORDER_WAIT_SEND", target = "ORDER_WAIT_RECEIVE")
    public boolean sendToReceive (Message<OrderStateChangeAction> message) {
        //TODO 待发货-》已发货
        return true;
    }

    @OnTransition(source = "ORDER_WAIT_RECEIVE", target = "ORDER_FINISH")
    public boolean receiveToFinish (Message<OrderStateChangeAction> message) {
        //TODO 已发货-》订单完成
        return true;
    }

}

```
OrderService中支付成功后回调方法内封装Message发送给OrderStateListener

```java
@Service
public class OrderService {

    public static final String stateMachineId = "orderStateMachine";

    @Autowired
    private StateMachineFactory<OrderState, OrderStateChangeAction> orderStateMachineFactory;

    @Autowired
    private RedisStateMachinePersister<OrderState, OrderStateChangeAction>  redisStateMachinePersister;

    @Autowired
    private RedisTemplate<String, String> stringStringRedisTemplate;

    /**
     * 支付回调
     * @param orderId 订单id
     * @return Order
     */
    public Order pay (String orderId) {
        Order order = getOrder();
        //包装订单状态变更message 附带订单操作pay_order
        Message<OrderStateChangeAction> message = MessageBuilder.withPayload(OrderStateChangeAction.PAY_ORDER)
                .setHeader("order", order).build();

        //传递给状态机
        if (changeStateAction(message, order)) {
            return order;
        }
        return null;
    }


    /**
     * 发送事件
     * @param message
     * @param order
     * @return
     */
    public boolean changeStateAction(Message<OrderStateChangeAction> message, Order order) {
        StateMachine<OrderState, OrderStateChangeAction> stateMachine = null;

        try {
            String key = order.getOrderId() + "STATE";
            stateMachine = orderStateMachineFactory.getStateMachine(stateMachineId);
            //启动状态机
            stateMachine.start();
            //从redis读取状态机 缓存key（自定义）
            redisStateMachinePersister.restore(stateMachine, key);
            //发送给OrderStateListener
            boolean result = stateMachine.sendEvent(message);
            //将更改完订单状态的 状态机 存储到 redis缓存
            redisStateMachinePersister.persist(stateMachine, key);
            return result;

        }catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (stateMachine != null) {
                //停止状态机
                stateMachine.stop();
            }
        }
        return false;
    }
    
    private Order getOrder() {
        //TODO 从Redis获取订单信息
        return null;
    }
}

```

在状态机中 最重要到是根据实际业务来定义状态类型和状态流转事件到类型，我们可以发现

状态机都是有状态的（Stateful）的，有状态意味着多线程并发情况下如果是单个实例就容易出现线程安全问题。

在如今的普遍分布式多线程环境中，你就不得不每次一个请求就创建一个状态机实例。

但问题来了：一旦碰到某些状态机它的构建过程很复杂，如果当下QPS又很高话，往往会造成系统的性能瓶颈。

Spring官方提供到stateMachine框架存在着上述问题，在此有兴趣的朋友看下阿里开源的状态机框架cola-statemachine：

阿里巴巴的cola-statemachine框架和Spring官方的Spring stateMachine框架都是基于状态机的框架，它们都可以用于实现状态机的建模和实现。它们的主要区别在于以下几个方面：

功能特性：cola-statemachine框架相比Spring stateMachine框架，提供了更加丰富的功能特性，例如支持状态机的嵌套、支持状态机的分布式部署、支持状态机的持久化和恢复等。这些功能特性可以满足更加复杂的业务场景，提高了框架的可用性和可扩展性。

性能和可靠性：cola-statemachine框架相比Spring stateMachine框架，具有更高的性能和可靠性。它采用了高性能的状态机引擎，可以支持高并发和高吞吐量的业务场景，同时也具有更好的容错和恢复能力。

易用性和可扩展性：cola-statemachine框架相比Spring stateMachine框架，具有更好的易用性和可扩展性。它提供了更加简洁和易用的API，可以快速地实现状态机的建模和实现，同时也支持自定义状态机的扩展和定制。

总之，cola-statemachine框架相比Spring stateMachine框架，具有更加丰富的功能特性、更高的性能和可靠性、更好的易用性和可扩展性，可以满足更加复杂的业务场景，是一个更加优秀的状态机框架。

原型模式
---

##### 应用场景

大量相似对象的创建：当需要创建大量的相似对象，但创建对象的过程比较耗时时，可以使用原型模式，先创建一个对象作为原型，然后通过复制原型对象的方式来创建新对象，避免重复创建相似的对象，提高创建对象的效率。

隐藏对象的创建细节：当创建对象的过程比较复杂，需要进行很多复杂的初始化操作时，可以使用原型模式，将对象的创建过程隐藏在原型对象的内部，对外只提供一个复制原型的方法，将对象的创建细节隐藏起来，简化了对象的创建过程。

动态配置对象：当需要动态配置对象的属性时，可以使用原型模式，先创建一个原型对象，然后根据需要动态地修改原型对象的属性，然后复制原型对象创建新对象。这样可以极大地方便对象的配置。

保护对象的数据安全：当需要在多个地方使用同一个对象时，但这个对象的数据需要保护，避免被其他地方修改时，可以使用原型模式，将对象的数据复制到新对象中，通过复制对象来避免数据被修改。

用于框架开发：在框架开发中，原型模式被广泛使用，例如Spring框架就通过原型模式创建Bean对象，然后根据需要动态地修改Bean对象的属性，最后将Bean对象注入到容器中，提供给用户使用。

##### 具体实现

在群发短信的场景下，如果需要大量的用户，如成千上万的用户，都需要进行短信通知。就可以使用原型模式

SmsTemplate定义了短信模版 一般配置在数据库中

```java
/**
 * 短信模版 包含了模版id 和模版内容
 */
public class SmsTemplate {

    /**
     * 短信模版id
     */
    private String templateId;

    /**
     * 短信模版内容
     */
    private String templateContent;

    /**
     * 短信类型 1-营销短信 2-通知短信
     */
    private Integer type;


    public SmsTemplate(String templateId, Integer type,  String templateContent) {
        this.templateId = templateId;
        this.templateContent = templateContent;
        this.type = type;
    }

    public SmsTemplate() {
    }

    public String getTemplateId() {
        return templateId;
    }

    public void setTemplateId(String templateId) {
        this.templateId = templateId;
    }

    public String getTemplateContent() {
        return templateContent;
    }

    public void setTemplateContent(String templateContent) {
        this.templateContent = templateContent;
    }

    public Integer getType() {
        return type;
    }

    public void setType(Integer type) {
        this.type = type;
    }
}

```
SmsRequest封装了第三方平台sdk或者接口的数据对象 因为需要创建大量的对象 所以在SmsRequest对象中实现了Cloneable接口

并重写了clone方法

```java
/**
 * 请求第三方平台对象 注意 必须 实现Cloneable 重写clone方法
 */
public class SmsRequest implements Cloneable{

    /**
     * 用户手机
     */
    private Long userPhone;

    /**
     * 短信模版
     */
    private String templateContent;

    /**
     * 短信类型 1-营销短信 2-通知短信
     */
    private Integer type;


    public Long getUserPhone() {
        return userPhone;
    }

    public void setUserPhone(Long userPhone) {
        this.userPhone = userPhone;
    }

    public Integer getType() {
        return type;
    }

    public void setType(Integer type) {
        this.type = type;
    }

    public String getTemplateContent() {
        return templateContent;
    }

    public void setTemplateContent(String templateContent) {
        this.templateContent = templateContent;
    }

    public SmsRequest(Long userPhone, Integer type,  String templateContent) {
        this.userPhone = userPhone;
        this.type = type;
        this.templateContent = templateContent;
    }

    /**
     * 替换短信内容
     * @param variables
     */
    public void replaceVariables (Map<String, String> variables) {
        String content = this.templateContent;
        for (Map.Entry<String, String> entry : variables.entrySet()) {
            String variablesName = entry.getKey();
            String variablesValue = entry.getValue();
            content = content.replace("{" + variablesName + "}", variablesValue);
        }
        this.templateContent =  content;
    }

    @Override
    protected SmsRequest clone() throws CloneNotSupportedException {
        SmsRequest clone = null;
        try {
            //使用该方法克隆原型对象
            clone = (SmsRequest) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        return clone;
    }

    @Override
    public String toString() {
        return "SmsRequest{" +
                "userPhone=" + userPhone +
                ", templateContent='" + templateContent + '\'' +
                ", type=" + type +
                '}';
    }
}
```

在SmsService中sendSms方法中 传入短信模版对象和要发送的用户信息和内容的map

sendSms在遍历用户信息前会创建SmsRequest类型的一个原型对象

调用第三方平台前 for循环的每次遍历用户数据时都会更具SmsRequest类型的一个原型对象克隆出一个新的对象

节省了创建SmsRequest的事件 因为如果要发给5000个用户 就需要创建5000个SmsRequest对象

使用原型模式就可以节省创建对象的时间

```java
public class SmsService {

    private final static String NAME = "name";

    private final static String COUPON = "coupon";

    public static void main(String[] args) throws CloneNotSupportedException {
        /**
         * 获取短信模版
         */
        SmsTemplate smsTemplate = new SmsTemplate("1", 1,
                "尊敬到{name}先生/女士，您的{coupon}元优惠券已发放到您到券包中，请登录添可小程序查看。");

        /**
         * 获取要发送的用户信息variablesMap 例如从数据库中查询用户手机号等
         */
        Map<String, Map<String, String>> variablesMap  = new HashMap<>();
        Map<String, String> valueMap = new HashMap<>();
        valueMap.put(NAME, "爱因斯坦");
        valueMap.put(COUPON, "8");
        variablesMap.put("18866665555", valueMap);


        Map<String, String> valueMap2 = new HashMap<>();
        valueMap2.put(NAME, "牛顿");
        valueMap2.put(COUPON, "10");
        variablesMap.put("18866664444", valueMap2);

        sendSms(variablesMap, smsTemplate);
    }

    /**
     *
     * @param variablesMap key 手机号 value 占位符和替换值到键值对
     * @param template 短信模版
     * @throws CloneNotSupportedException
     */
    public static void sendSms (Map<String, Map<String, String>> variablesMap, SmsTemplate template) throws CloneNotSupportedException {
        String templateContent = template.getTemplateContent();
        SmsRequest prototype = new SmsRequest(null, template.getType(), templateContent);//创建原型对象
        for (Map.Entry<String, Map<String, String >> entry : variablesMap.entrySet()) {
            String phoneNumber = entry.getKey();
            Map<String, String> variables = entry.getValue();
            SmsRequest request = prototype.clone();//克隆原型对象
            request.replaceVariables(variables);
            request.setUserPhone(Long.valueOf(phoneNumber));
            sendSms(request);
        }

    }

    private static void sendSms (SmsRequest smsRequest) {
        System.out.println("sendSms" + smsRequest.toString());
    }


}
```
组装的数据结果如下：

```java
    Connected to the target VM, address: '127.0.0.1:55121', transport: 'socket'
    sendSmsSmsRequest{userPhone=18866665555, templateContent='尊敬到爱因斯坦先生/女士，您的8元优惠券已发放到您到券包中，请登录添可小程序查看。', type=1}
    sendSmsSmsRequest{userPhone=18866664444, templateContent='尊敬到牛顿先生/女士，您的10元优惠券已发放到您到券包中，请登录添可小程序查看。', type=1}
    Disconnected from the target VM, address: '127.0.0.1:55121', transport: 'socket'
```

在该案例中，使用了浅拷贝的方式，浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归复制引用对象。

而深拷贝的话得到的时一份完完全全的对立对象。所以如果使用深拷贝的话，更加耗时，更加耗内存。

如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，

就可能由数据被修改的风险，就会变得复杂，所以一般在操作大量数据非常感觉耗时时，推荐浅拷贝来处理。

责任链模式
---

##### 应用场景


##### 具体实现

在新版添可电器商城中，创建订单的业务功能就使用了责任链模式

OrderProcess接口定义处理订单的方法

```java

package org.project.order.service.order;


public interface OrderProcess {

    /**
     * 开始处理
     *
     * @param saveOrderVo 原始保存数据
     * @param orderList   订单处理数据
     * @param chain       链条
     */
    void doProcess(SaveOrderVo saveOrderVo, List<OrderProcessDataDto> orderList, OrderProcessChain chain);
}
```

接着根据创建订单逻辑，来实现OrderProcess接口

如BeforeOrderProcess类实现创建订单前置处理

```java
@Slf4j
public class BeforeOrderProcess implements OrderProcess {

    @Override
    public void doProcess(SaveOrderVo saveOrderVo, final List<OrderProcessDataDto> orderList, OrderProcessChain chain) {
        //下单事务此处开启
        TransactionTemplate transactionTemplate = WebUtil.getBean(TransactionTemplate.class);
        transactionTemplate.executeWithoutResult(status -> {
            try {
                //获取并删除购物车数据
                List<UserCartEntity> userCartEntities = WebUtil.getBean(UserCartService.class).queryAndRemoveUserCarts(saveOrderVo.getCartIds());
                //订单商品列表
                List<OrderGoodsProcessDataDto> orderGoodsList = null;
                if (!CollectionUtils.isEmpty(saveOrderVo.getOrderGoodsList())) {
                    //用户传入商品不为空
                    orderGoodsList = convertForSaveOrderGoods(saveOrderVo.getOrderGoodsList());
                } else if (!CollectionUtils.isEmpty(userCartEntities)) {
                    //购物车存在商品
                    orderGoodsList = convertForCart(userCartEntities);
                }
                AssertUtil.state(!CollectionUtils.isEmpty(orderGoodsList), new I18nBusinessException("BeforeOrderProcess.noOrderGoods"));
                assert orderGoodsList != null;
                //补充下单商品数据
                fillOrderGoodsProcessData(orderGoodsList);
                //补充组合商品数据信息
                fillCombinationGoods(orderGoodsList);
                //开始拆单，店铺订单商品列表字典项
                splitOrderAndFillExtInfo(saveOrderVo, orderList, orderGoodsList);
                //获取redis模板
                StringRedisTemplate redisTemplate = WebUtil.getBean(StringRedisTemplate.class);
                //需要保存进redis中的信息
                Map<String, String> multiSaveMap = new HashMap<>();
                orderList.forEach(orderProcessData -> multiSaveMap.put(CacheKeyConstant.ORDER_CREATING_PREFIX + orderProcessData.getOrderId(), DateUtil.format(DateUtil.getNowDate(), DateUtil.STANDARD_FORMATTER)));
                try {
                    //保存订单号进入redis表示正在创建订单
                    redisTemplate.opsForValue().multiSet(multiSaveMap);
                    //进入下一个链条
                    chain.doProcess(saveOrderVo, orderList);
                } finally {
                    //删除redis正在创建订单的标识
                    redisTemplate.delete(multiSaveMap.keySet());
                }
            } catch (Exception e) {
                status.setRollbackOnly();
                throw e;
            }
        });
        //发送下单成功通知事件
        WebUtil.getApplicationContext().publishEvent(new OrderSuccessEvent(orderList));
    }

    /**
     * 购物车实体 -> 订单商品处理数据
     *
     * @param userCartEntities 购物车实体列表
     * @return 订单商品处理数据列表
     */
    private List<OrderGoodsProcessDataDto> convertForCart(List<UserCartEntity> userCartEntities) {
        List<OrderGoodsProcessDataDto> result = new ArrayList<>();
        userCartEntities.forEach(userCartEntity -> result.add(new OrderGoodsProcessDataDto()
                .setGoodsId(userCartEntity.getGoodsId()).setGoodsCount(userCartEntity.getGoodsCount())));
        return result;
    }

    /**
     * 用户商品实体 -> 订单商品处理数据
     *
     * @param goodsList 商品列表
     * @return 订单商品处理数据列表
     */
    private List<OrderGoodsProcessDataDto> convertForSaveOrderGoods(List<SaveOrderGoodsVo> goodsList) {
        List<OrderGoodsProcessDataDto> result = new ArrayList<>();
        goodsList.forEach(goods -> result.add(new OrderGoodsProcessDataDto()
                .setGoodsId(goods.getGoodsId()).setGoodsCount(goods.getGoodsCount())));
        return result;
    }

    /**
     * 填充订单商品处理数据
     *
     * @param orderGoodsList 订单商品列表
     */
    private void fillOrderGoodsProcessData(List<OrderGoodsProcessDataDto> orderGoodsList) {
        //补充下单商品数据
        List<GoodsForOrderDto> goodsInfoList = FeignResultUtil.getData(WebUtil.getBean(GoodsClient.class).obtainGoodsForOrder(orderGoodsList.stream().map(OrderGoodsProcessDataDto::getGoodsId).collect(Collectors.toList())));
        //key -> goodsId
        Map<String, GoodsForOrderDto> goodsInfoMap = goodsInfoList.stream().collect(Collectors.toMap(GoodsForOrderDto::getGoodsId, item -> item, (o1, o2) -> o2));
        orderGoodsList.forEach(orderGoodsProcessDataDto -> {
            GoodsForOrderDto goodsInfo = goodsInfoMap.get(orderGoodsProcessDataDto.getGoodsId());
            AssertUtil.state(goodsInfo != null, String.format("商品: %s, 状态异常", orderGoodsProcessDataDto.getGoodsId()));
            assert goodsInfo != null;
            BeanUtils.copyProperties(goodsInfo, orderGoodsProcessDataDto);
            //设置商品现金支付金额
            orderGoodsProcessDataDto.setPaymentPrice(orderGoodsProcessDataDto.getGoodsPrice().multiply(BigDecimal.valueOf(orderGoodsProcessDataDto.getGoodsCount())));
            //设置商品实际支付金额=商品现金支付金额
            orderGoodsProcessDataDto.setActualPrice(orderGoodsProcessDataDto.getPaymentPrice());
        });
    }

    /**
     * 补充组合商品数据信息
     *
     * @param orderGoodsList 订单商品列表
     */
    private void fillCombinationGoods(List<OrderGoodsProcessDataDto> orderGoodsList) {
        //组合商品IDs
        List<String> combinationGoodsIds = orderGoodsList.stream().filter(orderGoodsProcessDataDto -> Boolean.TRUE.equals(orderGoodsProcessDataDto.getCombination())).map(OrderGoodsProcessDataDto::getGoodsId).distinct().collect(Collectors.toList());
        if (CollectionUtils.isEmpty(combinationGoodsIds)) {
            return;
        }
        //组合商品列表
        List<CombinationGoodsForOrderDto> combinationGoodsForOrderList = FeignResultUtil.getData(WebUtil.getBean(GoodsClient.class).obtainCombinationGoodsForOrder(combinationGoodsIds));
        //组合商品列表字典项（key -> 组合商品ID）
        Map<String, List<CombinationGoodsForOrderDto>> combinationGoodsForOrderListMap = new HashMap<>();
        combinationGoodsForOrderList.forEach(combinationGoodsForOrder -> combinationGoodsForOrderListMap.computeIfAbsent(combinationGoodsForOrder.getCombinationGoodsId(), k -> new ArrayList<>()).add(combinationGoodsForOrder));
        orderGoodsList.forEach(orderGoodsProcessData -> {
            if (Boolean.TRUE.equals(orderGoodsProcessData.getCombination())) {
                orderGoodsProcessData.setCombinationGoodsList(combinationGoodsForOrderListMap.get(orderGoodsProcessData.getGoodsId()));
            }
        });
    }

    /**
     * 开始拆单，并补充订单附加数据
     *
     * @param saveOrderVo    保存订单参数
     * @param orderList      订单列表
     * @param orderGoodsList 订单商品列表
     */
    private void splitOrderAndFillExtInfo(SaveOrderVo saveOrderVo, List<OrderProcessDataDto> orderList, List<OrderGoodsProcessDataDto> orderGoodsList) {
        //定义需生成的订单列表
        Map<String, List<OrderGoodsProcessDataDto>> shopOrderGoodsListMap = new HashMap<>();
        orderGoodsList.forEach(orderGoodsProcessData -> shopOrderGoodsListMap.computeIfAbsent(orderGoodsProcessData.getShopId(), k -> new ArrayList<>()).add(orderGoodsProcessData));
        //用户地址信息获取
        UserAddressDto userAddress = null;
        if (!StringUtil.isEmpty(saveOrderVo.getAddressId())) {
            userAddress = FeignResultUtil.getData(WebUtil.getBean(UserAddressClient.class).detailById(saveOrderVo.getAddressId()));
        } else if (saveOrderVo.getManualOrder() != null && saveOrderVo.getManualOrder().getUserAddress() != null) {
            userAddress = saveOrderVo.getManualOrder().getUserAddress();
        }
        //查询店铺信息
        Map<String, ShopDto> shopMap = FeignResultUtil.getData(WebUtil.getBean(ShopClient.class).obtainShopMap(shopOrderGoodsListMap.keySet()));
        //生成的订单号列表
        for (String shopId : shopOrderGoodsListMap.keySet()) {
            List<OrderGoodsProcessDataDto> orderGoodsProcessDataList = shopOrderGoodsListMap.get(shopId);
            //获取店铺
            ShopDto shop = shopMap.get(shopId);
            AssertUtil.state(shop != null, String.format("店铺:%s, 不存在", shopId));
            assert shop != null;
            OrderProcessDataDto item = new OrderProcessDataDto();
            BeanUtils.copyProperties(saveOrderVo, item);
            item.setShopId(shopId).setShopName(shop.getName()).setCountryCode(shop.getCountryCode());
            //生成订单号
            item.setOrderId(IdWorker.getIdStr());
            //设置商品数据
            item.setOrderGoodsProcessDataList(orderGoodsProcessDataList);
            //实物商品数量
            long count = orderGoodsProcessDataList.stream().filter(orderGoodsProcessDataDto -> BaseGoodsTypeEnum.NORMAL.name().equals(orderGoodsProcessDataDto.getGoodsType())).count();
            if (count > 0) {
                //存在实物商品，赋值用户地址信息
                AssertUtil.state(userAddress != null, new I18nBusinessException("BeforeOrderProcess.noReceiveAddress"));
                assert userAddress != null;
                item.setUserAddress(userAddress);
            } else {
                //纯虚拟商品下单，无须填写物流信息，赋值为空地址
                item.setUserAddress(new UserAddressDto()
                        .setId(StringUtil.EMPTY_STRING).setName(StringUtil.EMPTY_STRING).setMobile(StringUtil.EMPTY_STRING)
                        .setProvince(StringUtil.EMPTY_STRING).setCity(StringUtil.EMPTY_STRING)
                        .setDistrict(StringUtil.EMPTY_STRING).setAddress(StringUtil.EMPTY_STRING)
                        .setZipcode(StringUtil.EMPTY_STRING).setIsDefault(false));
            }
            //设置发票数据
            item.setUserInvoice(saveOrderVo.getUserInvoice());
            //买家留言信息
            if (!CollectionUtils.isEmpty(saveOrderVo.getBuyerRemarkMap())) {
                item.setBuyerRemark(saveOrderVo.getBuyerRemarkMap().get(shopId));
            }
            orderList.add(item);
        }
    }
}
```

除了BeforeOrderProcess（订单前置数据处理）外，还有DeductStockOrderProcess（扣减商品库存），ActivityOrderProcess（活动处理），
CouponOrderProcess（优惠券处理），ShippingFeeOrderProcess（运费处理），IntegralOrderProcess（积分处理），
ECardOrderProcess（E卡处理），OrderPriceCalculateOrderProcess（订单金额计算处理）， FinishOrderProcess（最终保存订单处理）
共计8个process，我们需要将这8个process组装成一个链条放入责任链中，在创建订单后，触发责任链，依次处理这8个业务逻辑。

##### 组装责任链

在项目resources目录下建一个META.services目录

在该目录下创建一个名为org.project.order.service.order.OrderProcess的文件

内容为

    org.project.order.service.order.process.BeforeOrderProcess ##订单前置数据处理
    org.project.order.service.order.process.DeductStockOrderProcess ##扣减商品库存
    org.project.order.service.order.process.ActivityOrderProcess ##活动处理
    org.project.order.service.order.process.CouponOrderProcess ##优惠券处理
    org.project.order.service.order.process.ShippingFeeOrderProcess ##运费处理
    org.project.order.service.order.process.IntegralOrderProcess ##积分处理
    org.project.order.service.order.process.ECardOrderProcess ##E卡处理
    org.project.order.service.order.process.OrderPriceCalculateOrderProcess ##订单金额计算处理
    org.project.order.service.order.process.FinishOrderProcess ##最终保存订单处理

OrderProcessChain接口定义责任链

```java
public interface OrderProcessChain {

    /**
     * 开始处理
     *
     * @param saveOrderVo 原始保存订单数据
     * @param orderList   订单处理数据
     */
    void doProcess(SaveOrderVo saveOrderVo, List<OrderProcessDataDto> orderList);
}

```

OrderProcessHandler创建下单方法doOrder，和内部类DefaultOrderProcessChain来组装上面8个订单Process

```java
@Component
public class OrderProcessHandler implements InitializingBean {

    /**
     * 订单处理链条
     */
    private OrderProcessChain orderProcessChain;

    /**
     * 开始下单
     *
     * @param orderList 订单处理数据
     */
    public void doOrder(SaveOrderVo saveOrderVo, List<OrderProcessDataDto> orderList) {
        orderProcessChain.doProcess(saveOrderVo, orderList);
    }

    /**
     * 默认订单处理链条
     */
    private static class DefaultOrderProcessChain implements OrderProcessChain {

        /**
         * 索引字段
         */
        private final int index;

        /**
         * 订单处理类列表
         */
        private final List<OrderProcess> orderProcessList;

        DefaultOrderProcessChain(List<OrderProcess> processList) {
            this.orderProcessList = processList;
            this.index = 0;
        }

        private DefaultOrderProcessChain(DefaultOrderProcessChain parent, int index) {
            this.orderProcessList = parent.getOrderProcessList();
            this.index = index;
        }

        public List<OrderProcess> getOrderProcessList() {
            return orderProcessList;
        }

        @Override
        public void doProcess(SaveOrderVo saveOrderVo, List<OrderProcessDataDto> orderList) {
            if (this.index < orderProcessList.size()) {
                OrderProcess orderProcess = orderProcessList.get(this.index);
                DefaultOrderProcessChain chain = new DefaultOrderProcessChain(this, this.index + 1);
                orderProcess.doProcess(saveOrderVo, orderList, chain);
            }
        }
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        ServiceLoader<OrderProcess> serviceLoader = ServiceLoader.load(OrderProcess.class);
        List<OrderProcess> processList = new ArrayList<>();
        for (OrderProcess orderProcess : serviceLoader) {
            processList.add(orderProcess);
        }
        if (CollectionUtils.isEmpty(processList)) {
            return;
        }
        //组装链条
        orderProcessChain = new DefaultOrderProcessChain(processList);
    }
}
```
在Bean的初始化阶段会调用afterPropertiesSet方法，使用ServiceLoader.load方法解析加载我们最开始定义在resources.META-INF.services下面的org.project.order.service.order.OrderProcess文件

这是基于SPI思想 通过JDK自带的ServiceLoader来扫描配置信息来加载业务实现。将我们的8个Process类进行加载实例化，最终放在我们的orderProcessChain的orderProcessList数组中

用户下单接口只需要注入OrderProcessHandler并调用doOrder方法，即可开始处理下单责任链的8个业务流程

我们回到BeforeOrderProcess类中，可以看到这样一行代码

```java
                    //进入下一个链条
                    chain.doProcess(saveOrderVo, orderList);
```

因为我们在DefaultOrderProcessChain中重写了doProcess方法，所以BeforeOrderProcess在处理完逻辑后，调用chain.doProcess(),

进入的就是DefaultOrderProcessChain中的doProcess方法，在方法内根据获取当前Process的下标，然后加1进入下一个Process的doProcess方法

在8个Process中都会在方法结束时doProcess，传递责任链并调用责任链中下一个Process，共同来完成创建订单的流程。

一直到this.index < orderProcessList.size() == false 结束整个责任链的处理流程。

```java
        @Override
        public void doProcess(SaveOrderVo saveOrderVo, List<OrderProcessDataDto> orderList) {
            if (this.index < orderProcessList.size()) {
                OrderProcess orderProcess = orderProcessList.get(this.index);
                DefaultOrderProcessChain chain = new DefaultOrderProcessChain(this, this.index + 1);
                orderProcess.doProcess(saveOrderVo, orderList, chain);
            }
        }

        private DefaultOrderProcessChain(DefaultOrderProcessChain parent, int index) {
                this.orderProcessList = parent.getOrderProcessList();
                this.index = index;
                }
```

至此使用责任链来实现整个创建订单的流程就结束了。







