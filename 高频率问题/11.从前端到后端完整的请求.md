## UI - 后端服务器

-> 本地host 解析 API URL 封装成http/https
-> DNS 
-> 本地网关\路由器（公网地址还是局域网地址）
-> NAT 私有IP转公有IP
-> ISP(公网地址走ISP，ISP有很多路由，找到目标服务器所在机房)
-> 防火墙：丢弃，拒绝，允许
-> 服务器网卡：硬中断（返回快，屏蔽重复的硬中断），软中断(异步解析数据)，TCP（三次握手：SYN,SYN-ACK,sock-id）；物理光纤接收，数据链路层，接收以太网帧，检查MAC地址，访问DMA直接内存（环形缓冲区 rx ring）

### 本地解析与封装

目标：生成可以发送的 HTTP/HTTPS 请求

Host 解析：
应用层（浏览器、程序）根据 API 的 URL（如 https://api.example.com/v1/data）提取出主机名 api.example.com。
DNS 查询：
操作系统通过 DNS 客户端向配置的 DNS 服务器查询该域名的 IP 地址。
可能经过：
本地缓存（hosts 文件）
局域网 DNS（路由器）
ISP 的 DNS
根域名服务器递归查询
最终得到目标服务器的 公网 IP 地址。

### 本地网络与网关

目标：将数据包发出局域网

本地网关/路由器：
如果目标 IP 不在本地子网内，则数据包会被发送到默认网关（通常是路由器）。
路由器可能有 局域网地址（私有 IP） 与 公网地址（ISP 分配）。
NAT（网络地址转换）：
将你的设备的私有 IP（如 192.168.x.x）转换为路由器的公网 IP。
同时建立 NAT 映射表，以便服务器返回数据时能正确找到你的设备。

### ISP 与互联网路由

目标：通过互联网找到目标服务器

ISP（Internet Service Provider）负责将你的数据包送入互联网骨干网。
数据包经过多个路由器（BGP 路由），逐步靠近目标服务器所在的机房或数据中心。
每个路由节点都会根据路由表选择下一跳（最优路径）。

### 网络安全层

目标：控制流量与安全策略

防火墙（本地、路由器、ISP、服务器端都有）：
丢弃（Drop）：不回应，静默丢弃。
拒绝（Reject）：返回错误响应。
允许（Allow）：放行请求。

### 服务器端处理

目标：接收并解析请求

服务器网卡（NIC）：
物理层：光纤或电缆接收信号。
数据链路层：接收以太网帧，检查目标 MAC 地址。
DMA（直接内存访问）：网卡将数据放入内存中的环形缓冲区（rx ring）。
硬中断：通知 CPU 有数据到达。
软中断：操作系统异步处理数据包。
TCP 层（三次握手）：
客户端发送 SYN（请求建立连接）
服务器返回 SYN-ACK（确认并响应）
客户端发送 ACK（确认连接建立） → 建立一个 socket 通道（sock-id）

TCP层通过内核的socket hash表 找到对应的socket struct
将HTTPS 带过来的数据payload存储到 socket struct的数据接收缓存区receive buffer中

应用层（HTTP/HTTPS）：
服务器解析请求头、路径、参数。
如果是 HTTPS，先进行 TLS 握手（证书验证、密钥交换）。
然后返回响应数据。


## 后端服务器

## Tomcat

初始化工作线程池(max thread) 去从任务队列拿数据 工作线程线程通过take()和poll()方法将自己的状态变为waiting

poller线程 通过epoll wait方法 去检查socket 缓冲区 有没有可读的payload数据

如果有封存成processor（SocketProcessor） 放入任务队列 工作线程从waiting状态变为running状态

SocketProcessor.run()方法从内核缓存区 复制数据 到 JVM的ByteBuffer

## JVM

https解析payload（请求头 请求行 请求体）封装成Request 和Response

接着到doFilter chainDoFilter（责任链）到DispatcherServlet 标志着 请求到达了真正意义上的Spring架构

然后到 确定处理器：handleMapping （@RequestMapping @Controller）

再到HandleInterrupter 请求拦截 （如果返回false 请求就解释了）

再到@RequestBody @RequestParameter 变成Java对象 执行Java代码

## 返回

ReturnHandle（@ResponseBody）