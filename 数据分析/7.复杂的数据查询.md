```sql
WITH

-- 1. 提前过滤年/月/周，缩小基础数据范围 + 提取周数字

profit_loss_base AS (

SELECT

pl.`year`,

pl.`month`,

pl.`week`,

-- 提取周的数字部分（关键：用于排序）

CAST(SUBSTRING(pl.`week`, 2) AS UNSIGNED) AS week_num,

pl.`version`,

pl.prod_sap_id,  -- 新增：保留prod_sap_id用于关联

SUM(pl.fin_income_after_rebate_acct_exrate_cny) AS sales_income,

SUM(pl.actual_cost_cny) AS sales_cost,

SUM(pl.gp_after_rebate_acct_exrate_cny) AS gross_profit,

SUM(pl.income_tax) AS income_tax,

SUM(pl.net_profit) AS net_profit,

SUM(pl.fin_income_after_rebate_mgr_exrate_cny) AS budget_sales_income,

SUM(pl.gp_after_rebate_mgr_exrate_cny) AS budget_gross_profit

FROM

ecovacs_agent.ecovacs_agent_fin_profit_loss_week_df pl

WHERE

pl.`version` IN ('预算', '实际')

AND pl.`year` = #{year}

AND pl.`month` <= #{month}

AND pl.`week` <= #{week}

-- 新增：筛选所属经营单体

AND pl.belong_business_entity = '国际事业部'

AND pl.sale_region_grp = 'EMEA'

AND pl.admin_org = 'Amazon Vendor'

AND pl.sale_region = 'EMEA'

GROUP BY

pl.`year`,

pl.`month`,

pl.`week`,

pl.`version`,

pl.prod_sap_id  -- 新增：按prod_sap_id分组

),

-- 2. 费用表关联已过滤的损益表，新增周维度关联 + 提取周数字

fee_base AS (

SELECT

f.`year`,

f.`month`,

f.`week`,

CAST(SUBSTRING(f.`week`, 2) AS UNSIGNED) AS week_num,

f.`version`,

f.prod_sap_id,  -- 新增：保留prod_sap_id用于关联

SUM(CASE WHEN f.fee_lvl_2 = 'Selling Exp' THEN f.fee_amount_acct_exrate_cny ELSE 0 END) AS selling_fee,

SUM(CASE WHEN f.fee_lvl_2 = 'Marketing Exp' THEN f.fee_amount_acct_exrate_cny ELSE 0 END) AS marketing_fee,

SUM(CASE WHEN f.fee_lvl_2 = 'HR Exp' THEN f.fee_amount_acct_exrate_cny ELSE 0 END) AS hr_fee,

SUM(CASE WHEN f.fee_lvl_2 = 'SG&A' THEN f.fee_amount_acct_exrate_cny ELSE 0 END) AS sga_fee,

SUM(CASE WHEN f.fee_lvl_2 = '研发费用' THEN f.fee_amount_acct_exrate_cny ELSE 0 END) AS rnd_fee,

SUM(CASE WHEN f.fee_lvl_2 = '管理费用' THEN f.fee_amount_acct_exrate_cny ELSE 0 END) AS admin_fee,

SUM(CASE WHEN f.fee_lvl_2 = '财务费用&税费' THEN f.fee_amount_acct_exrate_cny ELSE 0 END) AS finance_tax_fee,

SUM(CASE WHEN f.division_mgr_demand = '集团费用' THEN f.fee_amount_acct_exrate_cny ELSE 0 END) AS group_fee_base,

SUM(CASE WHEN f.fee_lvl_2 = '营业外收益' THEN f.fee_amount_acct_exrate_cny ELSE 0 END) AS non_operating_income

FROM

ecovacs_agent.ecovacs_agent_fin_fee_week_df f

INNER JOIN profit_loss_base pl

ON f.`year` = pl.`year`

AND f.`month` = pl.`month`

AND f.`week` = pl.`week`

AND f.`version` = pl.`version`

AND f.prod_sap_id = pl.prod_sap_id  -- 新增：prod_sap_id关联条件

WHERE

f.`version` IN ('预算', '实际')

GROUP BY

f.`year`,

f.`month`,

f.`week`,

f.`version`,

f.prod_sap_id  -- 新增：按prod_sap_id分组

),

-- 3. 合并损益和费用数据，补充周字段 + 周数字

combined_base AS (

SELECT

COALESCE(pl.`year`, f.`year`) AS `year`,

COALESCE(pl.`month`, f.`month`) AS `month`,

COALESCE(pl.`week`, f.`week`) AS `week`,

COALESCE(pl.week_num, f.week_num) AS week_num, -- 新增周数字

COALESCE(pl.`version`, f.`version`) AS `version`,

COALESCE(pl.prod_sap_id, f.prod_sap_id) AS prod_sap_id,  -- 新增：保留prod_sap_id

COALESCE(pl.sales_income, 0) AS sales_income,

COALESCE(pl.sales_cost, 0) AS sales_cost,

COALESCE(pl.gross_profit, 0) AS gross_profit,

COALESCE(f.selling_fee, 0) AS selling_fee,

COALESCE(f.marketing_fee, 0) AS marketing_fee,

COALESCE(f.hr_fee, 0) AS hr_fee,

COALESCE(f.sga_fee, 0) AS sga_fee,

COALESCE(f.rnd_fee, 0) AS rnd_fee,

COALESCE(f.admin_fee, 0) AS admin_fee,

COALESCE(f.finance_tax_fee, 0) AS finance_tax_fee,

COALESCE(f.group_fee_base, 0) + COALESCE(pl.sales_income, 0) * 0.005 AS group_fee,

COALESCE(f.non_operating_income, 0) AS non_operating_income,

COALESCE(pl.income_tax, 0) AS income_tax,

COALESCE(pl.net_profit, 0) AS net_profit,

COALESCE(pl.budget_sales_income, 0) AS budget_sales_income,

COALESCE(pl.budget_gross_profit, 0) AS budget_gross_profit

FROM

profit_loss_base pl

LEFT JOIN fee_base f

ON pl.`year` = f.`year`

AND pl.`month` = f.`month`

AND pl.`week` = f.`week`

AND pl.`version` = f.`version`

AND pl.prod_sap_id = f.prod_sap_id  -- 新增：prod_sap_id关联条件



UNION ALL

SELECT

f.`year`,

f.`month`,

f.`week`,

f.week_num, -- 新增周数字

f.`version`,

f.prod_sap_id,  -- 新增：保留prod_sap_id

0 AS sales_income,

0 AS sales_cost,

0 AS gross_profit,

f.selling_fee,

f.marketing_fee,

f.hr_fee,

f.sga_fee,

f.rnd_fee,

f.admin_fee,

f.finance_tax_fee,

f.group_fee_base + 0 * 0.005 AS group_fee,

f.non_operating_income,

0 AS income_tax,

0 AS net_profit,

0 AS budget_sales_income,

0 AS budget_gross_profit

FROM

fee_base f

LEFT JOIN profit_loss_base pl

ON f.`year` = pl.`year`

AND f.`month` = pl.`month`

AND f.`week` = pl.`week`

AND f.`version` = pl.`version`

AND f.prod_sap_id = pl.prod_sap_id  -- 新增：prod_sap_id关联条件

WHERE

pl.`year` IS NULL

),

-- 3.1 新增：聚合combined_base，移除prod_sap_id（关键步骤）

-- 从这里开始不再考虑prod_sap_id，将所有prod_sap_id的数据聚合

combined_aggregated AS (

SELECT

cb.`year`,

cb.`month`,

cb.`week`,

cb.week_num,

cb.`version`,

-- 移除prod_sap_id，改为聚合所有产品的数据

SUM(cb.sales_income) AS sales_income,

SUM(cb.sales_cost) AS sales_cost,

SUM(cb.gross_profit) AS gross_profit,

SUM(cb.selling_fee) AS selling_fee,

SUM(cb.marketing_fee) AS marketing_fee,

SUM(cb.hr_fee) AS hr_fee,

SUM(cb.sga_fee) AS sga_fee,

SUM(cb.rnd_fee) AS rnd_fee,

SUM(cb.admin_fee) AS admin_fee,

SUM(cb.finance_tax_fee) AS finance_tax_fee,

SUM(cb.group_fee) AS group_fee,

SUM(cb.non_operating_income) AS non_operating_income,

SUM(cb.income_tax) AS income_tax,

SUM(cb.net_profit) AS net_profit,

SUM(cb.budget_sales_income) AS budget_sales_income,

SUM(cb.budget_gross_profit) AS budget_gross_profit

FROM

combined_base cb

GROUP BY

cb.`year`,

cb.`month`,

cb.`week`,

cb.week_num,

cb.`version`

),

-- 4. 计算周粒度累计值（核心修改：分区改为年+月+版本，排序仅保留周数字）

current_cumulative AS (

SELECT

cb.*,

-- 窗口函数分区：年+月+版本（仅当月内累计）；排序：周数字（当月内按周序累加）

SUM(cb.sales_income) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS sales_income_sum,

SUM(cb.sales_cost) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS sales_cost_sum,

SUM(cb.gross_profit) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS gross_profit_sum,

SUM(cb.selling_fee) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS selling_fee_sum,

SUM(cb.marketing_fee) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS marketing_fee_sum,

SUM(cb.hr_fee) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS hr_fee_sum,

SUM(cb.sga_fee) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS sga_fee_sum,

SUM(cb.rnd_fee) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS rnd_fee_sum,

SUM(cb.admin_fee) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS admin_fee_sum,

SUM(cb.finance_tax_fee) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS finance_tax_fee_sum,

SUM(cb.group_fee) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS group_fee_sum,

SUM(cb.non_operating_income) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS non_operating_income_sum,

SUM(cb.income_tax) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS income_tax_sum,

SUM(cb.net_profit) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS net_profit_sum,

SUM(cb.budget_sales_income) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS budget_sales_income_sum,

SUM(cb.budget_gross_profit) OVER (PARTITION BY cb.`year`, cb.`month`, cb.`version` ORDER BY cb.week_num) AS budget_gross_profit_sum

FROM

combined_aggregated cb  -- 使用聚合后的数据，不再包含prod_sap_id

),

-- 5. 筛选目标年/月/周数据

target_cumulative AS (

SELECT * FROM current_cumulative

WHERE `year` = #{year}

AND `month` = #{month}

AND `week` = #{week}

),

-- 6. 关联去年同期数据（周维度）

concurrent_data AS (

SELECT

curr.*,

prev.sales_income AS sales_income_concurrent,

prev.sales_cost AS sales_cost_concurrent,

prev.gross_profit AS gross_profit_concurrent,

prev.selling_fee AS selling_fee_concurrent,

prev.marketing_fee AS marketing_fee_concurrent,

prev.hr_fee AS hr_fee_concurrent,

prev.sga_fee AS sga_fee_concurrent,

prev.rnd_fee AS rnd_fee_concurrent,

prev.admin_fee AS admin_fee_concurrent,

prev.finance_tax_fee AS finance_tax_fee_concurrent,

prev.group_fee AS group_fee_concurrent,

prev.non_operating_income AS non_operating_income_concurrent,

prev.income_tax AS income_tax_concurrent,

prev.net_profit AS net_profit_concurrent

FROM

target_cumulative curr

LEFT JOIN current_cumulative prev

ON curr.`year` - 1 = prev.`year`

AND curr.`month` = prev.`month`

AND curr.`week` = prev.`week`

AND curr.`version` = prev.`version`

),

-- 7. 生成层级1数据（仅保留所需字段）

level1_data AS (

SELECT

cd.`year` AS stat_year,

cd.`month` AS stat_month,

cd.`week` AS stat_week,

cd.`version`,

lv1.level_1,

CASE lv1.level_1

WHEN '销售收入' THEN cd.sales_income

WHEN '销售成本' THEN cd.sales_cost

WHEN '销售毛利' THEN cd.gross_profit

WHEN 'Selling' THEN cd.selling_fee

WHEN 'Marketing' THEN cd.marketing_fee

WHEN '人力成本' THEN cd.hr_fee

WHEN 'SG&A' THEN cd.sga_fee

WHEN '研发中心费用' THEN cd.rnd_fee

WHEN '职能总部费用' THEN cd.admin_fee

WHEN '财务费用&税费' THEN cd.finance_tax_fee

WHEN '集团费用' THEN cd.group_fee

WHEN '加：营业外收益' THEN cd.non_operating_income

WHEN '所得税费用' THEN cd.income_tax

WHEN '净利润' THEN cd.net_profit

END AS current_amount,

CASE lv1.level_1

WHEN '销售收入' THEN cd.budget_sales_income

WHEN '销售毛利' THEN cd.budget_gross_profit

ELSE CASE lv1.level_1

WHEN '销售收入' THEN cd.sales_income

WHEN '销售成本' THEN cd.sales_cost

WHEN '销售毛利' THEN cd.gross_profit

WHEN 'Selling' THEN cd.selling_fee

WHEN 'Marketing' THEN cd.marketing_fee

WHEN '人力成本' THEN cd.hr_fee

WHEN 'SG&A' THEN cd.sga_fee

WHEN '研发中心费用' THEN cd.rnd_fee

WHEN '职能总部费用' THEN cd.admin_fee

WHEN '财务费用&税费' THEN cd.finance_tax_fee

WHEN '集团费用' THEN cd.group_fee

WHEN '加：营业外收益' THEN cd.non_operating_income

WHEN '所得税费用' THEN cd.income_tax

WHEN '净利润' THEN cd.net_profit

END

END AS budget_amount,

CASE lv1.level_1

WHEN '销售收入' THEN cd.sales_income_concurrent

WHEN '销售成本' THEN cd.sales_cost_concurrent

WHEN '销售毛利' THEN cd.gross_profit_concurrent

WHEN 'Selling' THEN cd.selling_fee_concurrent

WHEN 'Marketing' THEN cd.marketing_fee_concurrent

WHEN '人力成本' THEN cd.hr_fee_concurrent

WHEN 'SG&A' THEN cd.sga_fee_concurrent

WHEN '研发中心费用' THEN cd.rnd_fee_concurrent

WHEN '职能总部费用' THEN cd.admin_fee_concurrent

WHEN '财务费用&税费' THEN cd.finance_tax_fee_concurrent

WHEN '集团费用' THEN cd.group_fee_concurrent

WHEN '加：营业外收益' THEN cd.non_operating_income_concurrent

WHEN '所得税费用' THEN cd.income_tax_concurrent

WHEN '净利润' THEN cd.net_profit_concurrent

END AS concurrent_amount,

CASE lv1.level_1

WHEN '销售收入' THEN cd.sales_income_sum

WHEN '销售成本' THEN cd.sales_cost_sum

WHEN '销售毛利' THEN cd.gross_profit_sum

WHEN 'Selling' THEN cd.selling_fee_sum

WHEN 'Marketing' THEN cd.marketing_fee_sum

WHEN '人力成本' THEN cd.hr_fee_sum

WHEN 'SG&A' THEN cd.sga_fee_sum

WHEN '研发中心费用' THEN cd.rnd_fee_sum

WHEN '职能总部费用' THEN cd.admin_fee_sum

WHEN '财务费用&税费' THEN cd.finance_tax_fee_sum

WHEN '集团费用' THEN cd.group_fee_sum

WHEN '加：营业外收益' THEN cd.non_operating_income_sum

WHEN '所得税费用' THEN cd.income_tax_sum

WHEN '净利润' THEN cd.net_profit_sum

END AS current_sum,

cd.sales_income AS sales_income_ref

FROM

concurrent_data cd

CROSS JOIN (

SELECT '销售收入' AS level_1 UNION ALL

SELECT '销售成本' UNION ALL

SELECT '销售毛利' UNION ALL

SELECT 'Selling' UNION ALL

SELECT 'Marketing' UNION ALL

SELECT '人力成本' UNION ALL

SELECT 'SG&A' UNION ALL

SELECT '研发中心费用' UNION ALL

SELECT '职能总部费用' UNION ALL

SELECT '财务费用&税费' UNION ALL

SELECT '集团费用' UNION ALL

SELECT '加：营业外收益' UNION ALL

SELECT '所得税费用' UNION ALL

SELECT '净利润'

) lv1

),

-- 8. 拆分实际/预算数据

actual_data AS (SELECT * FROM level1_data WHERE version = '实际'),

budget_data AS (SELECT * FROM level1_data WHERE version = '预算')



-- 最终查询：仅保留至累计率字段

SELECT

a.stat_year AS '年度',

a.stat_month AS '月份',

a.stat_week AS '周',

a.level_1 AS '层级1',

ROUND(a.current_amount, 2) AS '当期额',

-- 当期率

IF(a.level_1 IN ('销售收入', '销售成本'), NULL,

CONCAT(ROUND(IF(a.sales_income_ref = 0, 0, a.current_amount / a.sales_income_ref * 100), 1), '%')) AS '当期率',

ROUND(IFNULL(a.concurrent_amount, 0), 2) AS '同期额',

-- 同期率

IF(a.level_1 IN ('销售收入', '销售成本'), NULL,

CONCAT(ROUND(IF(a.sales_income_ref = 0 OR a.concurrent_amount = 0, 0, a.concurrent_amount / a.sales_income_ref * 100), 1), '%')) AS '同期率',

ROUND(IFNULL(b.budget_amount, 0), 2) AS '预算额',

-- 预算率

IF(a.level_1 IN ('销售收入', '销售成本'), NULL,

CONCAT(ROUND(IF(a.sales_income_ref = 0 OR b.budget_amount = 0, 0, b.budget_amount / a.sales_income_ref * 100), 1), '%')) AS '预算率',

ROUND(a.current_amount - IFNULL(a.concurrent_amount, 0), 2) AS '同比变动金额',

-- 同比变动率

CONCAT(ROUND(IF(a.current_amount = 0, 0, (a.current_amount - IFNULL(a.concurrent_amount, 0)) / a.current_amount * 100), 1), '%') AS '同比变动率',

ROUND(a.current_amount - IFNULL(b.budget_amount, 0), 2) AS '预算金额偏差',

-- 预算达成率

CONCAT(ROUND(IF(b.budget_amount = 0, 0, a.current_amount / b.budget_amount * 100), 1), '%') AS '预算达成率',

ROUND(a.current_sum, 2) AS '当期累计额',

-- 累计率（最终保留的最后一个字段）

IF(a.level_1 IN ('销售收入', '销售成本'), NULL,

CONCAT(ROUND(IF(a.sales_income_ref = 0, 0, a.current_sum / a.sales_income_ref * 100), 1), '%')) AS '累计率'

FROM

actual_data a

LEFT JOIN budget_data b

ON a.stat_year = b.stat_year

AND a.stat_month = b.stat_month

AND a.stat_week = b.stat_week

AND a.level_1 = b.level_1

ORDER BY

a.stat_year,

a.stat_month,

a.stat_week,

CASE a.level_1

WHEN '销售收入' THEN 1

WHEN '销售成本' THEN 2

WHEN '销售毛利' THEN 3

WHEN 'Selling' THEN 4

WHEN 'Marketing' THEN 5

WHEN '人力成本' THEN 6

WHEN 'SG&A' THEN 7

WHEN '研发中心费用' THEN 8

WHEN '职能总部费用' THEN 9

WHEN '财务费用&税费' THEN 10

WHEN '集团费用' THEN 11

WHEN '加：营业外收益' THEN 12

WHEN '所得税费用' THEN 13

WHEN '净利润' THEN 14

END;
```

这是一个非常典型的财务经营分析报表（P&L损益表）生成查询。

具体来说，这段 SQL 用于生成 Ecovacs（科沃斯）国际事业部 Amazon Vendor 渠道（EMEA区域）的周度经营损益分析报告。

它不仅展示当周的数据，还计算了预算对比（Budget vs Actual）、**同比分析（YoY）以及月度累计（MTD）**情况。

# 一 详细逻辑解析（按代码执行流程）

可以将这段 SQL 拆解为以下 5 个主要阶段：

## 1. 数据准备与过滤 (Data Preparation)

### profit_loss_base (损益基础表):

从底表中提取收入（Sales）、成本（Cost）、毛利（GP）、税金和净利。

关键过滤: 锁定 International Business Unit (国际事业部), EMEA (欧洲中东非洲), Amazon Vendor (亚马逊自营渠道)。

周处理: 使用 CAST(SUBSTRING(week, 2) AS UNSIGNED) 把 "W01" 这种字符串转为数字 1，确保后续排序正确。

### fee_base (费用基础表):

提取各类运营费用（Selling, Marketing, HR, R&D, Admin 等）。

行转列: 使用 CASE WHEN 将原本在行里的费用科目（fee_lvl_2）转换成独立的列（selling_fee, marketing_fee 等）。

### combined_base (合并):

将“损益表”和“费用表”通过 LEFT JOIN + UNION ALL 的方式进行全连接（Full Join），确保即使某周只有费用没有收入（或反之）数据也不会丢失。

计算衍生费用: 比如 group_fee 包含了 0.5% 的销售收入提成逻辑。

## 2. 数据聚合 (Aggregation)

combined_aggregated:

关键动作: 这一步去掉了 prod_sap_id（产品ID）。

这意味着报表不再看单品维度的明细，而是将所有产品的各项财务指标汇总到“年/月/周/版本”的层级。

## 3. 窗口计算与对比 (Window Functions)

current_cumulative:

利用窗口函数 SUM() OVER (PARTITION BY ... ORDER BY ...) 计算月内累计值。

例如：第3周的累计额 = 第1周 + 第2周 + 第3周的数据。

target_cumulative:

根据用户输入的参数 (#{year}, #{month}, #{week})，筛选出“当前查看的那一周”的数据。

concurrent_data:

同比逻辑: 通过 curr.year - 1 = prev.year 自关联，获取去年同一周的数据（用于计算同比变动率）。

## 4. 结构重组 (Unpivoting/Transposing)

level1_data (核心技巧):

列转行: 原始数据是“宽表”（Income, Cost, Fee 在同一行）。

使用 CROSS JOIN 关联一个写死的包含14个科目的列表（'销售收入', '销售成本', ..., '净利润'）。

通过巨大的 CASE WHEN 语句，将不同的列映射到对应的“层级1 (Level 1)”行中。

结果: 将数据库表结构转换成了财务报表的标准行结构。

## 5. 最终报表生成 (Final Select)

将“实际数据 (actual_data)”与“预算数据 (budget_data)”左连接。

计算各类 KPI 指标：

当期率: 费用占收入的百分比。

同比变动: 今年 vs 去年。

预算达成率: 实际 vs 预算。

累计率: 月初至今的费用/利润率。

特殊处理: 对“销售收入”和“销售成本”行的比率字段做了置空处理（因为收入占收入比通常无意义或恒为100%）。

# 二 这段 SQL 解决了什么业务问题？

业务方（财务或管理层）可以通过这个查询直接看到一张完整的周报，回答以下问题：

本周赚了多少钱？（销售收入、毛利、净利）

钱花哪儿了？（营销费、研发费、管理费等各项费用明细）

和去年比怎么样？（是否有增长）

达到预算目标了吗？（主要看预算达成率）

这个月目前为止累计表现如何？（通过累计额判断月度目标风险）


# 三 StarRocks做这种复杂查询的性能表现如何? (实测查询接口请求耗时335ms)

针对这段 SQL，StarRocks 的性能表现通常是 毫秒级 或 秒级（取决于数据量级，几亿行数据通常也在秒级返回），比传统的 MySQL/Oracle 快 100-1000倍，比 Hive/Spark 快 10-100倍。

以下是具体的性能分析，分为 “为什么快” 和 “可能的瓶颈与优化” 两个部分。

## 为什么 StarRocks 跑这个 SQL 会很快？

这段 SQL 命中了 StarRocks 的多个核心加速机制：

### 1. 列式存储 (Columnar Storage)
   
SQL特征：你虽然表里可能有很多列，但查询只选取了 sales_income, fee_amount 等具体的财务指标列。

StarRocks优势：它只会读取这几列的数据，其他几十列完全不涉及 IO。相比 MySQL 的“行式存储”（必须把整行读出来再挑列），IO 效率极大提升。

### 2. 向量化执行引擎 (Vectorized Execution)
   SQL特征：大量的 SUM(), CASE WHEN, GROUP BY 计算。

StarRocks优势：它不是一行一行算的，而是利用 CPU 的 SIMD 指令集，一次处理一批数据（比如一次算 4096 行的销售额求和）。这对于那个长长的 fee_base 里的 CASE WHEN 聚合非常有效。

### 3. CBO 优化器 (Cost-Based Optimizer) 对 CTE 的处理
   SQL特征：你有 8 个 CTE（WITH ... AS），逻辑链路很长。

StarRocks优势：StarRocks 的优化器非常智能，它不会傻傻地把每个 CTE 都生成临时表。它会根据统计信息，决定是谓词下推（把 WHERE year=2025 推到最底层的扫描操作中），还是流水线执行。

特别是 Join：对于 profit_loss_base JOIN fee_base，StarRocks 会自动选择 Hash Join 或 Runtime Filter，大大减少数据 Shuffle。

### 4. 窗口函数的极速处理
   SQL特征：SUM() OVER (PARTITION BY ...) 计算当月累计。

StarRocks优势：这是 MPP 数据库的强项。它会在内存中并行处理分区排序和累加，比传统数据库的游标处理快得多。

### 5. 应对 Cross Join (Unpivoting)
   SQL特征：最后用 CROSS JOIN 那个 14 行的小表 (lv1) 把列转成行。

StarRocks优势：这是典型的 Broadcast Join 场景。StarRocks 会把这 14 行的小表广播到所有节点内存里，完全没有数据传输开销，瞬间完成“列转行”爆炸。

# 最终的大招：物化视图 (Materialized View)


如果这个报表是老板每天都要刷几十遍的高频报表，且数据量极大（百亿级）：

你可以基于 profit_loss_base 和 fee_base 的聚合逻辑，直接在 StarRocks 里建一个 异步物化视图。

效果：StarRocks 会在数据导入时自动把 SUM 算好存起来。当你查这个 SQL 时，它直接读结果，耗时基本是 0ms。